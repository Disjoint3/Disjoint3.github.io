[{"title":"GAME101-Lecture04学习","url":"/2024/04/19/GAME101-Lecture04学习/","content":"\n# 二维旋转矩阵的补充\n\n![image-20240419180446306](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419180446.png)\n\n第一行的式子，是上节讲到的二维的旋转矩阵（二维的变换不用齐次坐标表示的话，基本就是这种2\\*2的矩阵表示）\n\n第二行的式子，旋转-θ角。是将第一行的所有θ替换成-θ，然后化简得来的。\n\n- 观察可以发现，**旋转-θ的旋转矩阵，就是旋转θ的旋转矩阵的转置**。\n- 另外也可以，**旋转-θ的旋转矩阵，也是旋转θ的旋转矩阵的逆**。（第三行的式子。通过矩阵的定义，矩阵转成逆矩阵可知）\n- 从而可以得到性质：**在旋转里，旋转θ的旋转矩阵的转置 等于 旋转θ的旋转矩阵的逆**（在数学上，一个矩阵的逆等于它的转置，这个矩阵就是正交矩阵）\n- 如果想要让二维物体沿着相反的方向旋转相同的角度，那么写出一个正向旋转矩阵，然后转置即可。\n\n# 三维变换的补充\n\n![image-20240419182036017](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419182036.png)\n\n通过升维来表示三维变换。\n\n![image-20240419182154357](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419182154.png) \n\n和二维的变换一样，三维的仿射变换也是线性变换再平移变换的。\n\n## 缩放和平移（变换）\n\n![image-20240419182201446](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419182201.png)\n\n## 旋转（变换）\n\n### 旋转变换矩阵\n\n![image-20240419183923059](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419183923.png)\n\n三维的旋转分为绕着x、y、z三个轴旋转的情况。\n\n第一个式子中是绕着x轴旋转，可以发现：\n\n- x的值是不变的。因此在左上角3\\*3的线性变换矩阵中，其第一行和第一列都是100（图中蓝色框框）\n- y的值和z的值都是旋转的。因此左上角3\\*3的线性变换矩阵中，右下角的2\\*2的矩阵是变化的，这其实是因为y和z都旋转了相同角度。（图中红色框框）\n\n第三个式子中是绕着z轴旋转，和绕着x轴旋转的情况分析方式一样。\n\n第二个式子中是绕着y轴旋转，其式子就有些不同了。其旋转矩阵的值是其他的负值。\n\n- 坐标系的建立是用向量叉乘的方式建立的。本门课用的是右手螺旋定则判断正负（方向）。\n- 在确定x轴时可以用y叉乘z；z轴可以用x叉乘y。\n- 而y轴，只能用z叉乘x，x叉乘z是负值，所以其旋转矩阵的值是其他的负值\n\n### 欧拉角\n\n![image-20240419184148962](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419184149.png)\n\n- 从RX，Ry，Rz组成任意3D旋转?\n- 所谓欧拉角\n- 常用于飞行模拟器:滚转、俯仰、偏航\n\n任意的一个旋转，都可以写成绕x、y、z旋转的组合。\n\n三个轴旋转的旋转角，称为欧拉角。\n\n### 罗德里格斯旋转公式\n\n![image-20240419184530904](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419184530.png)\n\n简单来说就是将任意的旋转写成一个旋转公式，该公式可以将旋转“分解”到三个轴上。\n\n罗德里格斯公式提供了一个旋转矩阵，旋转矩阵定义了一个旋转轴n和旋转角度α。\n\n- 这里旋转轴默认过原点，那么就是起点是原点，方向是n，旋转角度是α旋转。\n- 如果要实现真正的绕任意轴旋转（即轴可以平移），那么就得平移这一条轴到能自转的情况（即让这个轴的起点与原点重合），先旋转（自传），转完再移回去。（所有的旋转都是自旋转，上节课提到的绕着某个点旋转也是得先平移让旋转点与原点重合，旋转完后再平移回去）\n- 图中公式最后的大N，就要看这个公式的推导。闫老师把推导过程的pdf发了出来，配合这个视频（[games101罗德里格斯旋转公式推导](https://www.bilibili.com/video/BV1qV411X79j/?share_source=copy_web&vd_source=8332072dc5586e92174abc96d6e4280f)）大概是明白了怎么推到的。（但自己推那是真搞不定，只能说数学水平真的决定计算机的上限。。。）\n- 推导过程中，有涉及到两个向量的叉乘。在进行两个向量的叉乘时，可以用矩阵的形式，因此才会出现最后面那个矩阵N。\n- （第二节的向量叉乘：）\n  ![image-20240419190235517](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419190235.png)\n  在三维中的两个向量的叉乘方法，就是图中第一条式子。而叉乘也可以写成下方第二条式子的样子（矩阵的形式)。\n\n## 四元数\n\n四元数是为了给旋转做差值才引入的。\n\n- 假设一个旋转矩阵是旋转15°，另一个是旋转25°。如果将两个矩阵加起来求平均，结果并不是20°。\n- 这是因为旋转矩阵不适合做差值。\n\n闫老师没有深入讲这个四元数，提了一嘴。后续自己会找些资料研究研究，毕竟unity里就有这个四元数。。\n\n# 观测变换\n\n变换其实是为了让三维的空间变成二维的图。\n\n## 视图变换\n\n### 引入\n\n![image-20240419195444944](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419195444.png)\n\n- 什么是视图转换\n- 想想怎么拍一张照片\n  --一找个好地方，安排人(**模式改造**)\n  --找一个好的“角度”来放相机(**视图变换**)\n  --“茄子！”(**投影变换**)\n\n模型视图投影变换，简称MVP变换。\n\n### 视图变换矩阵\n\n#### 矩阵概念定义\n\n![image-20240419195907247](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419195907.png)\n\n- 怎么进行视图变换？\n- 定义相机\n  --位置\n  --注视/凝视方向\n  --向上方向 (假设是 xx 观看)\n\n![image-20240419200208679](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419200208.png)\n\n- 关键观察\n  --如果相机和所有对象一起移动，“照片”将是相同的\n- 不如我们总是把摄像机转换成\n  --原点，在Y上，看-Z\n  --与相机一起变换对象\n\n![image-20240419200424122](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419200424.png)\n\n- 用 M<sub>view</sub> 变换相机\n  --它位于原点，在Y的上方，看-Z\n- M在数学中如何？\n  --将 e 平移到原点\n  --将g旋转到-Z\n  --将t旋转到Y\n  --旋转(g叉乘t 可以认为是图中绿色坐标轴) 至X\n  --很难写!\n\n#### 矩阵推导\n\n![image-20240419200939693](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419200939.png)\n\n- M<sub>view</sub>如何计算？\n  -- M<sub>view</sub> = R<sub>view </sub>T<sub>view</sub>\n- 平移到原点（T<sub>view</sub>就是平移矩阵）\n\n这里是先平移（T<sub>view</sub>平移矩阵）再线性变换（R<sub>view</sub>旋转矩阵）。\n\n对于R<sub>view</sub>，我们需要将视图的坐标系转成标准的坐标系。即g旋转到-Z；t旋转到Y；(g叉乘t)旋转到X。这样运算不好算，所以反过来让标准坐标系转成转到视图的坐标系。图中最后一行，就是用种思想进行的公式推导：\n\n- R<sub>view</sub>是视图的坐标系转成标准的坐标系的旋转矩阵。\n- R<sub>view</sub>直接求不好求，我们反过来，先求R<sub>view</sub><sup>-1</sup>。（前面二维矩阵补充提到，“在旋转里，旋转θ的旋转矩阵的转置 等于 旋转θ的旋转矩阵的逆”。）\n- R<sub>view</sub><sup>-1</sup>的求法则是和前面求“旋转矩阵的ABCD”一样，用特殊值法。\n- R<sub>view</sub><sup>-1</sup>求出来，R<sub>view</sub><sup>-1</sup> = R<sub>view</sub><sup>-T</sup>。\n- 此时让R<sub>view</sub><sup>-T</sup>再转置回去就可以得到R<sub>view</sub>。\n\n## 投影变换\n\n### 引入\n\n#### 投影\n\n![image-20240419203852807](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419203852.png)\n\n- 计算机图形学中的投影\n  --3D至2D\n  --正交投影\n  --透视投影\n\n上图的左下角是正交投影。正交投影并不会有近大远小的现象，透视会。\n\n上图的右下角是透视投影。原本平行的两条边，在这种投影下，会有相交。这里更像是人眼睛的效果。\n\n#### 摄像机的成像方式\n\n![image-20240419204016470](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419204016.png)\n\n左侧透视投影，摄像机放在某一个位置上看作一个点。以摄像机点为起点，做射线形成空间的一个锥体（视锥体）。在椎体中，通过“最远”和“最近”的设定，将“最远”和“最近”的区域的东西全显示在进出的图片上。\n\n### 正交投影\n\n![image-20240419204747544](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419204747.png)\n\n- 一个简单的方法来理解\n  --摄像头位于原点，看着-Z，向上看着Y(看起来很眼熟吗?)\n  --删除Z坐标\n  --将生成的矩形平移并缩放至[-1,1]<sup>2</sup>\n\n不管远处还是近处，全部放在一张图上。\n\n![image-20240419204932907](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419204932.png)\n\n我们要把一个立方体[l,r] x [b,t] x [**f,n**]映射到“标准(正则、规范、标准)” 的立方体[-1,1]<sup>3</sup>上\n\n空间中的任何一个立方体（最左侧的图），都可以通过平移、缩放等变换，变成一个标准的立方体（最右侧的图）。\n\nx轴表示左右（立方体的[l,r]），y轴表示上下（立方体的[b,t]），而z轴是远近（立方体的[**f,n**]。注意离我们更远，z的值应该是更大的，**f>=n**。这就是一些API 比如OpenGL用左手系）\n\n#### 正交矩阵\n\n![image-20240419205639065](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419205639.png)\n\n先做平移，再做缩放。\n\n### 透视投影\n\n#### 引入\n\n![image-20240419205909523](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419205909.png)\n\n- 最常见于计算机图形学、美术、视觉系统\n- 更远的物体更小\n- 不平行的。平行线汇聚成一点。\n\n![image-20240419210045840](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419210045.png)\n\n齐次坐标中，(x,y,z,1)乘上任意不为0的数，在三维中的坐标都是不变的，都是(x,y,z)。\n\n当(x,y,z,1)乘上z时，(xz,yz,z<sup>2</sup>)在三维中还是(x,y,z)。\n\n#### “挤压”投影\n\n![image-20240419211205862](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419211205.png)\n\n透视投影直接做或写出来比较困难。我们可以将远平面中间的位置，即这个Frustum（图形学中将远和近中间的区域叫做Frustum）从四棱竹的形状“挤”成立方体，然后再做正交投影即可。\n\n在“挤”的过程中，要做一些规定：\n\n1. 最近的平面不能变\n2. 要“挤”的z轴上的值不会变化（只向自己平面内中间收缩）\n3. 远平面的中心点也不会发生变化\n\n##### “挤压”矩阵\n\n![image-20240419211639970](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419211640.png)\n\n- 回忆一下关键思想：找出变换点(x’，y’，z’)和原始点(x，y，z)之间的关系\n\n通过相似三角形，可以得到变换点和原始点之间的关系。\n\n![image-20240419211756440](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419211756.png)\n\n图中第一个式子就是变换点和原始点之间的关系。\n\n图中第二个式子，是原始点到变换点的过程。(x,y,z,1)会被映射成最右边的向量。\n\n###### 矩阵推导\n\n![image-20240419212435348](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419212435.png)\n\n- 所以“挤压”(透视到正交)投影就是这样做的\n- 可以找出部分的M<sub>persp->ortho</sub>\n\nM<sub>persp->ortho</sub>就是挤压矩阵。\n\n图中第一个式子表示，用挤压矩阵M<sub>persp->ortho</sub>乘以原始点就可以得到最后的变换点。原始点和变换点都部分已知，求出挤压矩阵即可。\n\n图中第二个式子是求出的“挤压”矩阵（数学算出来的。。。）。第三行不知道，先放着。\n\n###### 矩阵第三行推导\n\n这里的推导，emmmm怎么说呢，还是在用特殊值推导。了解下推导过程就好。。\n\n![image-20240419213152008](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419213152.png)\n\n- 如何求出图中矩阵的第三行\n  --有什么有用的信息吗\n- 观察:第三排负责\n  --近平面上的任何点都不会改变\n  --远平面上的任何点的z都不会改变\n\n**信息1：近平面上的任何点都不会改变**\n\n![image-20240419213822775](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419213822.png)\n\n- 近平面上的任何点都不会改变。\n  用n代替z的值\n- 所以第三行一定会是(0 0 A B)的形式\n  n<sup>2</sup>与任何x y 上的值都无关\n\nn为近平面到摄像机的距离。\n\n这里就是先让原始点的z值为n，然后x y值依旧不知道。此时就会变成：矩阵第三行(? ? ? ?) 乘以 列矩阵(x,y,n,1) 等于n<sup>2</sup>。\n![image-20240419220446698](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419220637.png)\n即：?x+?y+?n+?=n<sup>2</sup>（矩阵的乘法，第i行分别乘以第i列的元素然后相加)\n\n然后观察 ?x+?y+?n+1=n<sup>2</sup> 这个式子，等号右边没有出现任何的x y，那么他们的系数只能是0。第三四个系数还是不知道，设为A B。因此就有了(0 0 A B)这个东西，从而能得到 An+B=n<sup>2</sup> 这个式子。\n\n**信息2：远平面上的任何点的z都不会改变**\n\n![image-20240419221059316](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419221059.png)\n\n和信息1一样，带入特殊值。f为近平面到摄像机的距离。\n\n在信息1推导出的(0 0 A B)基础上，带入f，可以得到Af+B=f<sup>2</sup>\n\n**联立解方程**\n\n![image-20240419221446659](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419221446.png)\n\n联立两个式子，用韦达定理解出了A B。此时就能够得到M<sub>persp->ortho</sub>“挤压”矩阵了。\n\n### 透视矩阵\n\n![image-20240419221607872](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419221607.png)\n\n通过“挤压”投影得到“挤压”矩阵后。先“挤压”再正交投影，就可以得到透视矩阵。\n\n# 总结\n\n## 二维三维补充\n\n今天先是对之前缩放、平移和旋转等这些变换在二维、三维上的一些补充。\n\n### 二维\n\n二维上是对旋转矩阵的补充。\n\n- 求物体旋转-θ时的旋转矩阵，发现R<sub>-θ</sub> = R<sub>θ</sub><sup>-T</sup>\n- 这里引出性质（理论上二维三维都通用）：**在旋转里，旋转θ的旋转矩阵的转置 等于 旋转θ的旋转矩阵的逆**。（数学上的正交矩阵）\n\n### 三维\n\n三维上时对缩放、平移和旋转变换的补充。\n\n- 三维的缩放和平移变换很简单，原理和二维的一致。\n- 三维的旋转变换，其会有绕x、y、z轴三个方向旋转的情况，对应的旋转矩阵都会不一样。\n- x和z的旋转矩阵分析方法一致。\n- 绕y轴的旋转矩阵比较特殊，其值是x 、y的旋转矩阵的负值。这是因为在右手系下，x叉乘y是-z。\n- 此外，还提及了四元数。由于矩阵不适合做差值，因此会用四元数。\n\n## 观测变换\n\n课上的重点是观测变换。观测变换有模型、视图、投影三种（简称MVP变换）\n\n个人理解模型变换像是“建模”这种，这里就不需要讨论。\n\n### 视图变换\n\n视图变换的主要原因是摄像机的摆放问题，抽象上来看，就是坐标系的建立和转换的问题。\n\n- 通过定义，我们规定了一套标准的坐标系。但是摄像机自身的坐标系并不一定与标准坐标系重合，这个时候我们需要进行坐标系的转换（视图变换）。\n- 视图变换时，要将视图（定义的摄像机的前后上下，原点，在Y上，看-Z）坐标轴通过平移、旋转等变换回到标准坐标系上。\n- 视图坐标的X轴是通过y和z叉乘得到，要将一个叉乘旋转比较麻烦。因此可以反过来，让标准坐标系旋转到视图坐标系上。接着通过前面的正交矩阵性质（在旋转里，旋转θ的旋转矩阵的转置 等于 旋转θ的旋转矩阵的逆），能够求出旋转矩阵。\n- 平移矩阵很简单，直接是原点的移动就可以得到\n- 视图变换是先旋转，再平移。通过旋转矩阵和平移矩阵，就可以算出视图矩阵。\n\n### 投影变换\n\n投影变换是将三维的画面投影到一张二维图像上，有正交和透视两种方式。\n\n#### 正交变换\n\n正交投影比较简单，平移变换加上缩放变换即可得到。同理正交矩阵也是通过平移矩阵和缩放矩阵就可以算出。\n\n#### 透视变换\n\n透视投影比较复杂。\n\n- 透视变换中为了不涉及坐标系之间的变换，引入了“挤压”的想法。透视投影做“挤压”投影，再做正交投影，就可以得到一张二维二维画像。\n- “挤压”投影的“挤压”矩阵推导起来比较复杂，后半节课都在干这个事情。\n- 总的来说，就是先利用相似三角形、变换点和原始点之间的关系和齐次方程的特性，得到出第三行以外的“挤压”矩阵值。\n- 第三行通过观察到的两个信息（挤压时近平面和远平面点的关系），带入特殊值解方程推出来的。\n- 算出“挤压”矩阵后，根据前面的正交矩阵，就能得到透视矩阵。\n\n# 课堂遗留问题\n\n在透视投影做“挤压”时，近平面的所有点不变，远平面的所有点z值不变。那么远近平面中间的点，经过“挤压”变换后，z值会如何变化呢？（这个点会被推向近平面，还是推向远平面）\n\n\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"算法练习day3","url":"/2024/04/19/算法练习day3/","content":"\n# 移除链表元素\n\n[代码随想录 移除链表元素](https://programmercarl.com/0203. 移除链表元素.htm)\n\n[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)\n\n（用时：0.5小时）\n\n## 普通方法\n\n普通的移除方法中，要将节点分为头结点和非头结点两类。\n\n- 如果头结点就是要移除的元素，那么直接让其next成为头节点即可（即缩头）\n- 如果是非头节点，让节点的前一节点的next指向要移除的节点的next即可。\n\n### 错误\n\n自己也没有想到，普通写的时候还出了好些问题，果然是不熟练啊。\n\n**错误：头节点不能用if，也要用while来筛除。**\n<u>如果用if，那就只判断了一次头节点，那万一头节点的下一个头节点也是要删的呢？</u>（也不知是不是unity的update写多了，写函数的时候脑子里一直是if也会循环hhh）\n\n## 虚拟头结点法\n\n虚拟头结点就是在原来的头结点前，增加一个头结点，让这个头结点暂时充当头结点。这样就消除头结点的特殊情况，少if判断。\n\n既然消除了头结点的特殊情况，题目也就变成了\n\n### 重点分析\n\n重点有以下三个：\n\n1. while中的判断条件？\n2. if判断的判断条件？\n3. if判断成立与否时，要做的操作、分别表示什么？\n4. currentNode的初始值？\n\n个人的理解如下：\n\n- if的判断\n\n  先考虑if的判断条件是因为while的判断条件要根据if的逻辑来写。\n  <u>当currentNodex.val等于要找的val移除当前节点，让需移除节点的前驱节点的next等于其下一节点（即frontNode.next = currentNode.next）。注意这里是知道需移除节点的前驱节点的，而这里用的又是单向链表，那就只有“未雨绸缪”，在它的前驱节点时就判断它是否要被移除，要的话让前驱节点实施才行。</u>\n  <u>不等于时，继续遍历。</u>\n\n- currentNode的初始值\n\n  currentNode的初始值就很简单了，根据前面这里的if判断，初始值应该是虚拟节点。\n\n- while中的判断条件？\n\n  所有的节点都是一类了，那么就只有这一个while了。while里的条件必定是让currentNodex停下来不继续遍历的。问题在于是currentNode还是currentNodex.next不等于null。\n  单独看while，这里两者好像都可以。但是我们得配合里面的if。<u>if判断的是currentNode.next.val是否为0，这个currentNode.next必须要是非null，.val才能引用，不然会报错。所以条件是currentNode.next!=null。</u>\n\n# 设计链表\n\n[代码随想录 设计链表](https://programmercarl.com/0707.设计链表.htm)\n\n[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/description/)\n\n（用时：1.5小时）\n\n# 思路分析\n\n这道题是设计类的题目。设计“类”的话，方法和思路就很多了。所以写的时候就老是在优化，觉得这里能写的更好，然后就写了好久。。。（怎么有点职业病的感觉hhh）\n\n这道题就是对链表的增删查改。增删改都要在查的基础上，但是题目需要实现的函数只是给定下标，返回值就好，这在数组的增删改上挺好的（数组的查也就是下标引用hhhh），但在链表上，就有点鸡肋了。于是最开始先写了个查的函数，给定下标，返回指向该节点的指针（不知道会不会有什么内存方面的浪费？以往写类都不是为了不是很注重算法的东西，写的又不是c++，对这方面不是很敏感）\n\n删和改的函数没什么好说的，主要就是利用这个查的函数。\n\n增的函数，可考虑的就多了。总所周知链表的插入有头插和尾插两种。刚开始写的时候没有想到虚拟头节点的运用，就用头插和尾插的角度进行了分析。后来进行了迭代，增加了虚拟头结点，不分什么头插尾插了。\n\n- 01：定义三个函数。（如果没有虚拟节点，那么最简洁方便的就是这样）\n  第一个，查找节点函数。给定index，返回指向第index个节点的指针。\n  第二个，头插法函数。给定index，在该index前面插入新节点\n\n  ![image-20240420000254838](C:/Users/14638/AppData/Roaming/Typora/typora-user-images/image-20240420000254838.png)第三个，尾插法函数。给定index，在该index后面插入新节点。\n  ![](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419160023.png)\n\n  插入节点分为三种情况：\n  1.增加头结点：在原来的头结点上用头插法；\n  2.增加尾节点：在原来的尾节点上用尾插法；\n  3.中间的节点：自主选择是在第index个节点上用头插还是尾插）\n\n- 02：定义两个函数。这里省略了头插法的函数，因为有了虚拟节点。\n  第一个，同上\n  第二个，尾插法函数。同上\n\n  有了虚拟头结点，插入节点的三种情况的思路稍微改变了：\n  1.增加头结点：在虚拟头结点处用尾插法；\n  2.增加尾节点：在原来的尾节点上用尾插法；\n  3.中间的节点：自主选择。若在index前面插入，则在index-1上用尾插法。若在index后面插入，则在index上用尾插法）\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 反转链表\n\n[代码随想录 反转链表](https://programmercarl.com/0206.反转链表.htm)\n\n[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)\n\n（用时：0.5小时）\n\n## 双指针法\n\n单向链表的节点的前驱节点自己是不知道的，因此在遍历和更改的时候，需要定义多个指针，防止断链的情况。画图分析：\n![image-20240419164846826](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419164846.png)\n随意找中间的某个节点进行翻转，发现至少需要一个cur指针用于向前遍历，front指针记录cur的前驱节点以及一个back指针记录后驱节点防止反转后cur无法进行遍历（看视频的时候，也有说back是临时的，所以不算第三个指针。)\n\n### 重点分析\n\n这道题有几个需要注意的重点：\n\n1. back指针记录cur后驱节点应在改变cur指针next朝向前进行，不然会cur处断链，cur后续无法继续遍历。\n2. front指针的更新应该在cur指针的更新之前，因为此时的front指针的next已经这次循环之前就被改了朝向。\n\n## 递归法\n\n能够被循环迭代实现的，一般都能写成递归。\n\n这道题由于已经给出了调用函数的定义，因此无法在其基础上改成递归函数。定义一个新的函数，用于处理递归的逻辑。\n\n- 递归的参数：递归函数的参数是要一直改变的值。在循环中，cur和 front的值一直在更新（back是临时的），因此递归的参数就是cur和front。\n- 递归的出口：递归函数的出口就是循环终止的条件。在循环中，while的终止条件是cur为null，因此这就是递归的出口。\n- 递归要处理的逻辑：递归的逻辑就是循环要做的东西。在循环中，其实是一直重复着临时指针back指向cur后驱节点、改变cur的next朝向和front、cur更新的操作。那在递归了也如此，只是注意front、cur的更新要在给递归函数传参时体现。\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习"],"categories":["computerStudy"]},{"title":"unity实现模拟鼠标测量距离","url":"/2024/04/18/unity实现模拟鼠标测量距离/","content":"\n# 思路分析\n\n做项目时，有一个测量距离的功能需要实现：假设屏幕中有四个点ABCD，它们之间可以互相到达。提前设置好了邻接矩阵以及他们之间的路径长度。现在需要用鼠标模拟点与点之间的测量过程。\n\n功能有些复杂，自己学艺不精，想出来的方案比较粗糙：\n\n- 首先需要解决\n"},{"title":"算法练习day2","url":"/2024/04/18/算法练习day2/","content":"\n# 有序数组的平方\n\n[代码随想录 有序数组的平方](https://programmercarl.com/0977.有序数组的平方.html)\n\n[力扣 977.有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)\n\n（用时：0.3小时）\n\n这道题很简单，可以用双指针法或者暴力破解。\n\n## 双指针法\n\n本题允许新构建数组，然后返回值可以是新的数组，因此个人认为才会比较简单。但如果不允许构建数组呢？\n\n- 题目提供的是一个有序的升序数组，数组中也会有负数和零。整个数组都平方后，数组的大小趋势应该是从两头向中间递减的，如图：\n  ![image-20240418171625395](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/18/20240418171632.png)\n- 指针head和tail顾名思义，分别从数组的头和尾开始遍历。\n- 在遍历的时候，比较头和尾的平方大小，大的放入新数组的尾部，不断比较放入，即可得到一个新的升序的平方数组。\n- 注意一下新数组是从后往前赋值的，因此新数组的下标初始值应为数组长度-1.\n\n## 暴力破解\n\n暴力破解就更简单了。\n\n- 将原数组按顺序平方后的值放入新数组中。\n- 再对新数组排序既可。\n\n## 代码实现\n\n**暴力破解：**\n\n```c#\n/// <summary>\n/// 暴力破解\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <returns></returns>\npublic int[] SquareOfArrayFun2(int[] nums)\n{\n    int[] ans = new int[nums.Length];\n\n    for (int i = 0; i < nums.Length; i++)\n    {\n        ans[i] = nums[i] * nums[i];\n    }\n\n    Array.Sort(ans);\n\n    return ans;\n}\n```\n\n**双指针法：**\n\n```c#\n/// <summary>\n/// 双指针法\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <returns></returns>\npublic int[] SquareOfArrayFun1(int[] nums)\n{\n    int[] ans = new int[nums.Length];\n    int head = 0, tail = nums.Length - 1, arrIndex = nums.Length;\n    \n    while(head <= tail)\n    {\n        if (nums[head]* nums[head] < nums[tail]* nums[tail])\n        {\n            ans[--arrIndex] = nums[tail] * nums[tail];\n            tail--;\n        }\n        else\n        {\n            ans[--arrIndex] = nums[head] * nums[head];\n            head++;\n        }\n    }\n\n    return ans;\n}\n```\n\n# 长度最小的子数组\n\n[代码随想录 长度最小的子数组](https://programmercarl.com/0209.长度最小的子数组.html)\n\n[力扣 209.长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n\n（用时：0.5小时）\n\n这道题其实难度不高，但是引入了滑动窗口的思想。\n\n\n\n## 滑动窗口\n\n滑动窗口是一个抽象的概念，在不同地方具体是什么都不太也一样。\n\n- 个人认为窗口其实就是一块“区域”，像是数学的“区间”。\n- 所谓滑动，个人认为是这块区域的起始和终点是可变意思，但是起点和终点始终会保持着起点<=终点这个条件（起点和终点的意义也是这样固定了）。\n- 合起来，滑动窗口可以认为就是一段可变的区间，变化的条件、区间要满足的要求都是人定的。利用这个思想，可以解决一些计算机的问题。\n\n（题外话：滑动窗口也让我想起来计网中的那个滑动窗口hhhh，思想都是很互通呢。）\n\n## 滑动窗口法\n\n本题本质其实就是要找数组中连续的数字，这些数字连在一起，可以看成一片“区域”。\n\n- 程序中，可以用两个指针（也不一定是真的指针）表示窗口的起点和终点。让起点和终点按照我们的要求改变，就可以实现查找区域的想法。\n- end指针先向后探索，从start到end这块区域的数相加如果>=target，那么就说明这块区域是符合要求的“子列”。\n- 由于要找最小子列长度，那么单单符合要求并不够，还得比较符合要求的所有子列的长度。此时可以靠start，从目前已经符合要求的start到end的区间中，后移减短子列长度。\n\nstart和end配合操作，总结来说：\n1.**先找到符合要求的子列**\n2.数一定要连续。依次**让起点往后挪，尝试是否有更加“完美”的子列。**\n\n### 重点思考\n\n写的时候，需要重点考虑以下问题：\n\n- 窗口的start如何定义和改变？\n- 窗口的end如何定义和改变？\n\n个人的一些理解：\n\n- 窗口的start如何定义和改变？\n\n  <u>start指针主要是用来在现有符合条件的子列上，缩短“优化”子列长度。</u>\n  <u>start只有在 s(当前子列和)>=Target时，才能start++以后移</u>\n  <u>start能够一直后移，一定是start++后，s(当前子列和)>=Target依旧成立。</u>（不用担心出现start>end而条件还成立的情况。因为s-nums[start]和start++是先后进行的，s的初值是0，target和数组都是正整数，0<正整数。）\n\n- 窗口的end如何定义和改变？\n\n  <u>end指针主要是用于寻找符合条件的子列，不负责“优化”。</u>\n  <u>end只有在找到s(当前子列和)>=Target时，才会停下来，让start“优化”。</u>\n  <u>end的边界条件是数组长度。</u>\n\n### 错误思考\n\n- 本题写的时候，思路上没有什么阻碍，实现上也是。\n- 但在一个地方出了问题：int的最大值。\n- 以前写习惯了，int的最大值直接定成65535，其实不是。\n- C#中可以用int.MaxValue来替代。\n\n## 暴力破解法\n\n暴力破解就是双层循环，遍历出所有的可能。\n\n# 代码实现\n\n**滑动窗口法：**\n\n```c#\n/// <summary>\n/// 滑动窗口法\n/// </summary>\n/// <param name=\"target\"></param>\n/// <param name=\"nums\"></param>\n/// <returns></returns>\npublic int SmallSubarrayFun1(int target, int[] nums)\n{\n    int start = 0, end = 0, subLen = int.MaxValue, s = 0;\n    while(end< nums.Length)\n    {\n        s += nums[end];\n        while (s>=target)\n        {\n            //先判断并更新目前最短的子列长度\n            if (end - start + 1 < subLen)\n            {\n                subLen = end - start + 1;\n            }\n            //接着尝试缩短窗口（start后移）\n            \n            s -= nums[start];\n            start++;\n        }\n        //缩短窗口完毕，继续让end向后探索\n        end++;\n    }\n    if (subLen== int.MaxValue)\n    {\n        return 0;\n    }\n    else\n    {\n        return subLen;\n    }\n}\n```\n\n# 拓展思考\n\n如果Target不一定是正整数或数组里包含负数或0呢？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习"],"categories":["computerStudy"]},{"title":"算法练习day1补充","url":"/2024/04/18/算法练习day1补充/","content":"\n# 前言\n\n昨天第一天时间太赶，没来得及把剩下的一题看了，今天补回来。\n\n# 移除元素\n\n[代码随想录  移除元素](https://programmercarl.com/0027.移除元素.html)\n\n[力扣 27.移除元素](https://leetcode.cn/problems/remove-element/description/)\n\n（用时0.5小时）\n\n这道题的解法有两种，一种是暴力破解，一种是快慢指针法。\n\n注意题目要求空间复杂度是O(1)，这表明需要在同一个数组中进行处理。\n\n## 暴力破解\n\n暴力破解很简单，两层嵌套循环。\n\n- 外层循环用于遍历整个数组，如果找到需要移除的元素，则开启内层循环。\n- 内存循环用来将该需移除元素后面的所有元素向前挪一位（题目要求元素原顺序不可变）。这样的时间复杂度大概是O(n方)\n\n### 注意重点\n\n暴力破解时，有个地方要注意：所有元素移完位置后，外层循环的循环遍历（一般是那个i），要 i-- 。\n\n- i--主要是因为，我们原本在这个第i位上发现他是要移除的，才将后面所有的元素前移一位。\n- 移完后第i位已经不是原来的那个元素了，此时需要再判断移动后的第i位是不是恰好也是要移除的元素\n- 即**可能会有连续几个元素都是要移除的**\n\n## 快慢指针法\n\n快慢指针需要小绕一下。\n\n- 快指针是对整个数组进行探索遍历，慢指针是对新的数组进行赋值遍历\n\n- 如果反应不过来，可以先把慢指针当成一个新的空的数组的指针。快指针对旧的数组进行遍历：\n\n  ​\t1.如果不是需要移除的元素，则利用慢指针加入新数组的空位中，慢指针向后移一位。快指针后移一位。\n\n  ​\t2.如果是需要移除的元素，新数组和慢指针不做处理。快指针后移一位。\n\n- 两个数组的想好了后，一个数组就简单了。只是将两个指针放到了同一个数组上进行处理。慢指针一定会等于或慢于快指针，因此不会出现问题。\n\n### 注意重点\n\n快慢指针法在写的时候，重点要考虑以下几点：（\n\n- arr[fastIndex] != val时，要做什么？\n- arr[fastIndex] = val时，要做什么？\n- return slowIndex？ 还是slowIndex+1？ 还是slowIndex-1？\n\n以下是个人的一些想法：\n\n- nums[fastIndex] != val时，要做什么？\n\n  <u>不等于时，表示该值不用被跳过，slowIndex要让其放入新数组。更新slowIndex，fastIndex继续探索既可。</u>\n\n- nums[fastIndex] = val时，要做什么？\n\n  <u>等于时，表示该值要被跳过，slowIndex不能放入新数组。让fastIndex继续向前探索即可。</u>\n\n- return什么？\n\n  <u>slowIndex始终是等待赋值的下一位，因此只用return slowIndex即可。</u>\n\n## 代码实现\n\n### 暴力破解\n\n```c#\n/// <summary>\n/// 暴力破解法\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <param name=\"val\"></param>\n/// <returns></returns>\npublic int RemoveElementFun2(int[] nums, int val)\n{\n    int cnt = 0;\n    for (int i = 0; i < nums.Length - cnt; i++)\n    {\n        if (nums[i] == val)\n        {\n            for (int j = i + 1; j < nums.Length - cnt; j++)\n            {\n                nums[j - 1] = nums[j];\n            }\n            cnt++;\n            i--;\n        }\n    }\n    return nums.Length - cnt;\n}\n```\n\n### 双指针法\n\n```c#\n/// <summary>\n/// 快慢指针方法\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <param name=\"val\"></param>\n/// <returns></returns>\npublic int RemoveElementFun(int[] nums, int val)\n{\n    int fastIndex, slowIndex;\n    fastIndex = slowIndex = 0;\n\n    while (fastIndex < nums.Length)\n    {\n        if (nums[fastIndex] != val)\n        {\n            nums[slowIndex] = nums[fastIndex];\n            fastIndex++;\n            slowIndex++;\n        }\n        else\n        {\n            fastIndex++;\n        }\n    }\n\n    return slowIndex;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习"],"categories":["computerStudy"]},{"title":"unity游戏中测量结果归一化处理","url":"/2024/04/18/unity游戏中测量结果归一化处理/","content":"\n# 需求分析\n\n在UGUI下，提前知道两点（设为A、B）之间的距离，以及他们的屏幕坐标。\n\n现在想要实现，鼠标从A点出发移动的偏移值映射到两点之间距离的区间中（即将鼠标相对A点的偏移数据处理到AB距离的范围内，以达到模拟真实测量的效果。\n\n（例如：让玩家点击A点后出现，从A点延申到鼠标上有一条线，通过拉线来实现测量的效果。）\n\n时间有点紧迫，也没有细想这样实现的可用性啥的。真诚希望有大佬指教！\n\n# 归一化公式\n\n使用的公式出处：[将数据归一化到任意区间范围的方法_数据 处理到 指定范围内-CSDN博客](https://blog.csdn.net/irober/article/details/115601223)\n\n# 代码实现\n\n**归一化函数：**\n\n```c#\n/// <summary>\n/// 将测量结果归一化\n/// </summary>\n/// <param name=\"min\">样本数据的最小值</param>\n/// <param name=\"max\">样本数据的最大值</param>\n/// <param name=\"left\">区间的左边界</param>\n/// <param name=\"right\">区间的有边界</param>\n/// <param name=\"value\">需要归一化的测量结果</param>\npublic float MeasureNormalization(float min,float max,float left,float right,float value)\n{\n    float temp;\n    if (min>max)\n    {\n        temp = min;\n        min = max;\n        max = temp;\n    }\n    if (left>right)\n    {\n        temp = left;\n        left = right;\n        right = temp;\n    }\n\n    return left + (right - left) / (max - min) * (value - min);\n}\n```\n\n**调用举例：**\n\n```c#\n//将鼠标的坐标转为屏幕坐标系的坐标\nRectTransformUtility.ScreenPointToLocalPointInRectangle( UI的画布RectTransform, 鼠标自己坐标系下的当前坐标, null, out 接收鼠标在屏幕坐标系下的坐标的变量);\n\n//归一化后的结果\nans = MeasureNormalization( 0, AB点屏幕坐标下的距离, 0, AB点认为规定要测量出来的距离, 鼠标在屏幕坐标系下的坐标);\n```\n\n\n\n\n\n","tags":["unity"],"categories":["computerStudy"]},{"title":"unity中鼠标与物体的交互","url":"/2024/04/18/unity中鼠标与物体的交互/","content":"\n# unity内置方法\n\nunity内置的OnMouseOver等方法，原理是利用射线检测。\n\n前提条件一是要有collider，二是摄像机要能够进行射线检测。\n\n- 在做的项目中，有个UGUI的2d物体无法使用OnMouseOver，猜测是因为摄像机实际上不是对着UI的。\n- **OnMouseOver这类方法，不适合对UI的拖拽进行处理，适合对3d物体的拖拽进行处理。**\n\n# unity EventTrigger组件\n\nEventTrigger的使用方法有很多，一是手动添加EventTrigger组件，然后对事件函数进行拖拽。二是可以重写接口。\n\n重写接口时，要注意，IBeginDrawHandler和IEndDrawHandler一定要有IDrawHandler才能实现。\n\n在鼠标拖拽时，UI物体与鼠标相差太远，原因可能是因为Canvas的Scale数值不是1，这时候要么就全调成1，要么就在脚本中除以相应的画布尺寸大小系数。\n\n# 学习视频链接\n\n学习时看的视频链接：【【盘点】Unity常用的三种拖拽方法（内置方法 + 接口 + Event Trigger组件）】 https://www.bilibili.com/video/BV1W541147GK/?share_source=copy_web&vd_source=8332072dc5586e92174abc96d6e4280f\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["unity"],"categories":["computerStudy"]},{"title":"GAME101-Lecture03学习","url":"/2024/04/17/GAME101-Lecture03学习/","content":"\n# 变换引入目的\n\n建模、3D转2D（投影）\n\n![image-20240417214811477](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417214818.png)\n\n# 缩放（变换）\n\n![image-20240417233641105](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233641.png)\n\n![image-20240417233647324](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233647.png)\n\n![image-20240417233701179](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233701.png)\n\n# 反射/对称（变换）\n\n![image-20240417233817350](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233817.png)\n\n# 切变\n\n![image-20240417214916402](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417214916.png)\n\n- 提示:\n- 水平位移在y=0处为0\n- 水平位移在y=1处为a\n- 垂直位移总是0\n\n整体：只是水平方向发生移动，竖直方向没有变化\n\n上面的边：水平方向移动的都是a\n\n中间的位置（y=0.5时）：水平方向移动都是0.5a\n\n总结可以认为，水平位置移动了a*y。x' = x+ay,y'=y，写成矩阵形式就是右下角的样子。\n\n# 旋转（变换）\n\n我们自己规定，任何旋转没有特地说明，都认为是绕着原点(0,0)旋转，旋转方向默认逆时针。\n\n## 旋转矩阵\n\n![image-20240417215439805](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417215439.png)\n\n## 旋转矩阵推导过程\n\n![image-20240417220007752](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417220007.png)\n\n列向量左乘矩阵\n\n- 首先，(x,y)--->(x',y')肯定是x和y分别乘以了某些系数，从而才能达到(x',y')的效果。（前面切变那里的分析过程\n- 按照切变的例子，向量(x',y')可以转化成向量乘矩阵的形式就是闫老师写出的那个ABCD的式子（图中黑色箭头尾端的式子）。此时问题就转化成了解出ABCD的值。\n- 要解矩阵，可以通过到带入特殊值的方式。最上面靠右的图就是闫老师演示的某种特殊情况，(1,0)--->(cosθ,sinθ)，将其带入待解式子即可（图中黑色部分）\n- 要完全解出来四个参数ABCD，找两个特殊解即可。\n\n（弹幕中有补充一般性的问题，闫老师这种解法是可以的）\n\n# 线性变换\n\n![image-20240417221233333](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417221233.png)\n\n如果能把变换写成上图的这种形式（即用矩阵乘以输入的坐标可以得到输出的坐标），这种变换叫做线性变换。\n\n即对于一个变换，用一个矩阵表示。\n\n# 齐次坐标\n\n**引入齐次坐标的主要原因是平移变换比较特殊，简单的表示成前面所需的一个矩阵乘以一个向量的形式，而不是让平移变换成为一个特殊的变换。**\n\n后续的推导起到帮助理解的作用。\n\n## 引入目的\n\n![image-20240417221910780](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417221910.png)\n\n![image-20240417221925820](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417221925.png)\n\n- 平移不能以矩阵形式表示(所以，翻译不是线性变换!)\n- 但我们不希望翻译成为一个特例\n- 是否有一种统一的方式来表示所有的转换?成本是多少\n\n平移的变换主要是加法，看着简单，但是像前面那样，通过矩阵的解法列出的话，会很复杂（如第二幅图）。（弹幕中说，这在线性代数中，叫做非齐次方程）\n\n并且，由于平移的变换中，矩阵乘法后面还要做一个加法，因此平移变换不是线性变换\n\n## 齐次坐标的解决方案\n\n用齐次坐标，通过增加一个数（一个维度）让平移变换写成矩阵乘以向量的形式（其他的线性变换也可以这么写），如下图(x',y',w')的变换：\n\n![image-20240417223038073](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417223038.png)\n\n## 齐次的“保护性”\n\n向量表示的是方向性，向量平移表示的任是同一个向量，这说明向量具有平移不变性。\n\n那么如果有一个向量(x,y,0)，经过矩阵的变换，若想让他不变（依旧是(x+t,y+t,0)）。可以增加一个0（一个维度）保护他。\n\n![image-20240417223410477](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417223410.png)\n\n- 齐次坐标\n- 如果结果的w坐标为1或0，则有效操作\n\n在空间中（二维或三维），向量加上向量（三角形法则）得到一个新的向量。\n\n点减去点，得到新的向量。\n\n点加上向量，点沿着一条线移动，移动到一个新的点上。\n\n点加点的扩充定义：在二维中，当w不等于0，可以让其转成（x/w,y/w,1)，w=1就可以表示成一个二维的点(x/w,y/w)。\n\n因此点加点得到的是这两个点的中点\n\n上述阐述了，最后一位是0，不仅保证了其平移不变性，还能保证在操作下是对的。\n\n\n\n# 仿射变换\n\n![image-20240417224820539](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417224820.png)\n\n图中上方的式子，我们称为仿射变换。\n\n在图中下方的式子中，我们用一个式子（齐次坐标）表示了所有的变换\n\n用齐次坐标去**表示二维的仿射变化**时，可以发现：\n\n- 矩阵的最后一行永远是001\n- 平移永远是写在最后一列的头两个数上\n- 前两列的前两个元素是原来线性变换的部分\n\n# 2D（二维）变换\n\n![image-20240417225121008](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225121.png)\n\n缩放变换中，没有平移，因此最后一列头两个数是00。\n\n旋转变换中，平移和缩放同理。\n\n平移变换中，没有经过线性变换，左上角是单位矩阵1001，有平移因此最后一列头两个数是tx ty。\n\n# 逆变换\n\n![image-20240417225508580](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225508.png)\n\n逆变换在矩阵中，就是乘以逆矩阵。\n\n# 组合变换\n\n![image-20240417225649265](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225649.png)\n\n- 如何才能从左边变换成右边？\n\n![image-20240417225656282](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225656.png)\n\n- 先平移再旋转，发现不可行\n\n![image-20240417225705466](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225705.png)\n\n- 先旋转在平移，发现可行\n\n通过上面的例子，可以知道\n\n- 复杂的变换可以通过简单的变化得到\n- 变换的顺序很重要\n- 这和矩阵的乘法一致，矩阵没有交换律\n\n![image-20240417225940346](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225940.png)\n\n向量默认时一个列矩阵，因此做变换的时候需要从左往右乘。（如图，列矩阵xy1先做旋转再做平移，因此先左乘一个R再左乘一个T）\n\n## 推广\n\n![image-20240417230313249](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417230313.png)\n\n- 仿射变换序列A1、A2、A3,…由矩阵乘法构成\n- 对性能非常重要！\n- 对n个矩阵进行预相乘以获得表示组合变换的单个矩阵\n\n先将前面的矩阵全部乘完，乘完还是一个3\\*3的矩阵。这说明一个3\\*3的矩阵可以表示很复杂的变换。\n\n# 分解变换\n\n![image-20240417230947003](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417230947.png)\n\n- 如何围绕一个给定的点c旋转?\n- 将中心转换为原点\n- 旋转\n- 移动回来\n\n相当于在二维中，图形绕着任意一个点旋转，都可以转换成：先把图形平移使得旋转点与原点重合，再绕原点旋转，然后再把旋转后的图形移回相同的参数\n\n# 3D变换\n\n三维空间的变换，可以类比二维的。\n\n注意区别，三维的点和向量增加一个数（升维）后，并不是四元数，四元数是专门用来表示旋转的。\n\n![image-20240417231500879](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417231500.png)\n\n- 再次使用齐次坐标\n\n![image-20240417231558326](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417231558.png)\n\n最后一行还是0001\n\n平移：依旧是在最后一列\n\n线性变换：左上角的3\\*3矩阵\n\n# 课堂启发\n\n可以把仿射变换写成一个简单的矩阵形式，矩阵表示线性操作和平移操作。\n\n# 课堂问题\n\n闫老师留下来的问题：在三维的变换中，矩阵应用在xyz这个三维点上，是先平移还是先线性变换呢？\n\n解答：可以看前面，2D下仿射变换的式子，是线性变换（矩阵乘以向量）加上平移变换。因此是先线性变换再平移变换。\n\n# 总结\n\n今天讲的是各种变换，前面所有的变换都是以2D为例的，3D其实也是同理。\n\n缩放、对称、旋转等这些变换，能够直接用矩阵乘以向量的形式表示，称为线性变换。\n\n平移不能以矩阵乘以向量表示，并不是平移变换。其形式是矩阵乘以向量加上一个矩阵，可以称之为仿射变换。\n\n如果将平移看作特殊的变化，那又太过麻烦。为了让所有的变换具有统一性，引入了齐次坐标的知识。\n\n齐次坐标能够通过加一个数（升维）的方式，通过齐次坐标来表示仿射变换。其次坐标也可以表示线性变换。\n\n因此，能够用齐次坐标的方式，将所有的变换转变成矩阵与向量的形式。\n\n将单一的变换累加，就是组合变换。组合变换中，变换的顺序很重要。\n\n在组合变换中发现，先将所有的变换矩阵相乘，还是能得到一个矩阵，这说明任何复杂的变换都能用一个矩阵来表示。\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"算法练习day1","url":"/2024/04/17/算法练习day1/","content":"\n# 前言\n\n大二开始定下实践项目的主方向后，对于数据结构、算法这一块基本就是停滞状态了。\n\n选择游戏方向后，unity和C#的实际项目对于算法方面的要求并不多。实习需要去大厂，并且为了进一步提高自己的能力，决定接下来的日子里苦练算法。\n\n以前练习算法这方面，用的都是C、Java这类。用C#写还是头一次，在练习算法的同时，增进自己对C#的使用熟练度，也是一举两得。\n\n接下来的日子，打算跟着卡哥的《算法随想录》刷题。根据http://t.csdnimg.cn/l8b7i，这篇大哥的博客，每天进行练习。自己练习确实得要很大的毅力和决心，希望自己能够坚持下来，共勉~\n\n# 二分查找\n\n[代码随想录 二分查找](https://www.programmercarl.com/0704.二分查找.html)\n\n[力扣 704.二分查找](https://leetcode.cn/problems/binary-search/)\n\n（用时：1.5小时）\n\n写的过程中出现了错误，思考了10分钟无法解决后，找了参考代码进行了纠错。错误如下：\n\n- 错误一：target < arr[mid]写成了target < mid\n- 错误二：写成了递归（也不算是错误，递归也能实现二分查找。但写的混合了递归和非递归，导致写的非常混乱！这也是对递归没有很好的理解。后来理清非递归后，重新写了下递归，一起放在后面了）\n- 错误三：左闭右开时，right = mid写成了right = mid-1\n\n## 错误复盘\n\n**错误一分析：**mid是一个下标，在target是一个值，比较的时候应是拿值比较。这里是对mid和target的关系没有更加深刻的理解，当查找到时，两者关系：target=arr[mid]\n\n**错误二分析：**写成了递归这个错误就emmmm，其实是可以写成递归的。递归之前也一直是迈不过去的坎，导致这里先入为主了。递归是写出来了，但并不是题目格式的要求。。每天的时间有限，第一遍刷更侧重于复习回顾理解，第二遍再拓展深究。\n\n**错误三分析：**\n\n- 卡哥视频二分查找有两个重点，一是while的判断条件，二是if里的判断条件。\n\n- while的判断条件看开闭区间，看left=right是否能取即可。\n\n- if判断条件也是看开闭区间，这里是看left是否能等于区间左侧、right是否能等于区间右侧\n\n  例如，假设  区间为[i,j)   mid=(i+j)/2，left=mid、左闭是可取的，right=mid、右开不可取\n\n  ![image-20240417185239607](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417185239.png)\n\n## 正解\n\n**左闭右闭：**\n\n```c#\n/// <summary>\n/// 左闭右闭\n/// </summary>\n/// <param name=\"arr\"></param>\n/// <param name=\"target\"></param>\npublic int Search1(int[] arr, int target)\n{\n    int mid, left, right;\n    left = 0;\n    right = arr.Length - 1;\n    //左闭右闭，left可以等于right\n    while (left <= right)\n    {\n        mid = (left + right) / 2;\n        if (target < arr[mid])\n        {\n            //右闭，mid可以取右边界，这里不用重复比较右边界，所以减一\n            right = mid - 1;\n        }\n        else if (target > arr[mid])\n        {\n            //左闭，mid可以取右边界，这里不用重复比较左边界，所以加一\n            left = mid + 1;\n        }\n        else\n        {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n\n**左闭右开：**\n\n```c#\n/// <summary>\n/// 左闭右开\n/// </summary>\n/// <param name=\"arr\"></param>\n/// <param name=\"target\"></param>\n/// <returns></returns>\npublic int Search2(int[] arr, int target)\n{\n    int mid, left, right;\n    left = 0;\n    right = arr.Length - 1;\n\n    while (left < right)\n    {\n        mid = (left + right) / 2;\n\n        if (target < arr[mid])\n        {\n            //右开，mid不可以取右边界，这里恰好也不用重复比较右边界，所以不变\n            right = mid;\n        }\n        else if (target > arr[mid])\n        {\n            //左闭，mid可以取右边界，这里不用重复比较左边界，所以加一\n            left = mid + 1;\n        }\n        else\n        {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n\n**尝试写的递归（并不符合题目条件，只是想训练一下自己递归的思路）：**\n\n```c#\n/// <summary>\n/// 左闭右闭，尝试写的递归，加上了left和right\n/// </summary>\n/// <param name=\"arr\"></param>\n/// <param name=\"left\"></param>\n/// <param name=\"right\"></param>\n/// <param name=\"target\"></param>\n/// <returns></returns>\npublic int Search3(int[] arr, int left, int right, int target)\n{\n    int mid;\n    mid = (left + right) / 2;\n    if (left>right)\n    {\n        return -1;\n    }\n    else\n    {\n        if (target < arr[mid])\n        {\n            return Search3(arr, left, mid - 1, target);\n        }\n        else if (target > arr[mid])\n        {\n            return Search3(arr, mid + 1, right, target);\n        }\n        else\n        {\n            return mid;\n        }\n    }\n}\n```\n\n# 后记\n\n今天实在是有点忙，还有一题没写，第二天一起补上呜呜呜。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习 二分查找"],"categories":["computerStudy"]},{"title":"行测_判断推理学习(一)：图形推理_位置规律","url":"/2024/04/16/行测-判断推理学习-一-：图形推理-位置规律/","content":"\n识别特征：元素组成相同\n\n# 考点一：平移\n\n方向：直线(上下、左右、斜对角线)、绕圈(顺逆时针)\n\n常见步数：恒定、递增(等差)\n\n# 考点二：旋转、翻转\n\n1.旋转\n方向：顺时针、逆时针\n常见角度45°、90°、180\n\n2.翻转\n左右翻转:竖轴对称\n上下翻转:横轴对称\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["行测 判断推理 图形推理 位置规律"],"categories":["civilStudy"]},{"title":"GAME101_Lecture02学习","url":"/2024/04/16/GAME101-Lecture02学习/","content":"\n# 向量复习\n\n图形学中，未作特殊规定的向量，缺省值（默认值）都是列\n\n![image-20240416184124364](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416184237.png)\n\n- 点积\n- 叉积\n- 正交基与坐标系\n\n\n\n## 点乘\n\n### 点乘基本知识\n\n![image-20240416172958213](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173005.png)\n\n左下角的公式中：点乘可以快速得到两个向量之间的夹角，特别是在两个向量都只是方向的时候。\n\n右下角的公式中：只要我们做一个反余弦，那就可以得到两个向量之间的夹角。 \n\n![image-20240416181413864](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416181414.png)\n\nA表示一个向量（默认列向量），AT是A向量的转置\n\nA的值可以用红色公式表示。\n\n\n\n### 直角坐标系的点积\n\n![image-20240416173414055](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173414.png)\n\n#### 图形学应用\n\n![image-20240416173442667](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173442.png)\n\n- 求两个向量之间的夹角(如光源与表面夹角的余弦)\n- 求一个向量在另一个向量上的投影\n\n\n\n### 投影点积\n\n![image-20240416173507601](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173507.png)\n\n点乘可以把一个向量任意的进行垂直与平行的分解\n\n上图计算向量b向量a的投影时，b的投影向量  = 向量b的长度 · cosθ · 向量a\n\n#### 图形学作用\n\n![image-20240416173534623](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173534.png)\n\n- 测量两个方向的距离\n- 分解向量\n- 确定向前/向后\n\n图形学中，可以计算两个向量或两个方向多么接近。主要通过比较点乘结果，可以判断接近还是远离这两个方向。\n\n![image-20240416173926813](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173926.png)\n\n向量的点乘还可以得到一个前与后的信息。\n\n如图假设向量a给定了某个方向，从a的起点向上为前，向下为后。\n\n向量a与b的点乘会为正数表示其的方向是指向a的前方。向量c反之。\n\n若向量a与某个向量的点乘为0，那么这个向量与向量a垂直。\n\n同理，前面说到点乘可以判断接近还是原理。向量b与向量a越来越远，那么两者的点乘还会越来越等于0（即垂直），随后更远就是与a的方向相反，直到点乘变成-1（此时b与a完全相反）。\n\n\n\n判断两个向量是否接近，其中一个应用——菲涅尔效果（看的角度和面的法线是否重合问题。越重合，说明面是对着相机的。否则面就越侧面（越亮），直到变成负数就是背面了（暗色））\n\n\n\n## 叉乘\n\n### 叉乘基本知识\n\n![image-20240416180608714](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416180608.png)\n\n- 叉积与两个初始向量正交\n- 右手定则确定方向\n- 在构造坐标系中很有用(以后)\n\n右手螺旋定则（有些地方会用左手），可以判断正负（方向）\n\n![image-20240416181639954](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416181640.png)\n\n左侧的公式中，如果在三维坐标系中，x叉乘y是z，那么这个坐标系就是一个右手坐标系。\n\n右侧的公式中，注意向量叉乘自己是0向量。并且叉乘只有反交换律。\n\n![image-20240416182118165](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416182118.png)\n\n在图中下方的公式，是向量可以写成矩阵的形式，然后向量的叉乘可以转换成矩阵乘以向量\n\n### 图形学的应用\n\n![image-20240416182340467](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416182409.png)\n\n- 确定左/右\n- 确定内部/外部\n\n在图形学中，叉乘一是判断左和右，另一个是判断内和外。\n\n![image-20240416182759510](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416182759.png)\n\n在左图中，向量a叉乘向量b、得到z是正的；向量b叉乘向量a、得到的z是负的。这两种都能证明b在a的左侧。\n\n在右图中，ABC的排布是逆时针，AB叉乘AP和BC叉乘AP、AC叉乘AP的z都是向外的（即AP都在所有边的左侧），这能说明P在ABC的中间。\n\nABC的排布变成顺时针也同理。（此处是对三角形做光栅化的基础，可以判断三角形覆盖了那些像素。若值等于0，即该像素刚好在三角形的边上，那么就自己定义）\n\n## 正交基与坐标系\n\n通过这些向量的乘法，就可以定义坐标系。定义坐标系可以把任意一个向量分解到三个轴上（利用点积算投影，然后用投影分解）\n\n![image-20240416190717359](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416190717.png)\n\n如图，假设将uvw设为一个三维坐标系的坐标轴，它们都是单位向量。\n\n假设有一个向量p。我们可以用投影的方式投影到坐标轴上，直接用点乘的结果就可以立刻得到投影的长度。原因解释如下：\n\n- 先假设向量p投影到u轴上，此时计算向量p在向量u上的投影向量。\n- p在向量u上的投影向量  = 向量p的长度 · cosθ · 向量u\n- 向量p点乘向量u=p的长度 × u的长度 × cosθ。\n- 此时u为单位向量，长度为1。\n- 那么，向量p点乘向量u = u的长度 × cosθ，正好就是其投影长度。\n- ![image-20240416200321655](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417184348.png)\n\n# 矩阵复习\n\n![image-20240416190822580](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416190822.png)\n\n- 神奇的2D阵列，在每一个CS课程中萦绕\n- 在图形学中，广泛用于表示变换翻译、旋转、剪切、缩放(下一讲更详细)\n\n## 矩阵乘积知识\n\n![image-20240416191421852](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416191421.png)\n\nm\\*n的矩阵 乘以 n\\*p的矩阵 = m\\*p的矩阵\n\n矩阵乘法运算，黑色框框和蓝色框框分别是两个例子：\n\n- 黑色框框的？，是在结果的第一行第二列，那么就去第一个矩阵中找第一行，第二个矩阵中找第二列，(1\\*6)+(3\\*7) = 27\n- 蓝色框框同理，(5\\*4)+(2\\*3) = 26\n\n![image-20240416192400862](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416192400.png)\n\n矩阵没有任何的交换率。结合律比较有用。\n\n![image-20240416192852730](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416192852.png)\n\n- 将向量视为列矩阵(mx1)\n- 转换点的关键(下一讲)\n- 官方剧透:关于y轴的2D反射\n\n 始终认为，矩阵在左边，向量在右边。 \n\n![image-20240416192945749](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416192945.png)\n\n矩阵的变换（转置）\n\n![image-20240416193013912](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416193014.png)\n\n# 矩阵和向量\n\n![image-20240416193056657](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416193056.png)\n\n向量在矩阵形式上的计算。\n\n# 总结\n\n这节课主要是对线性代数中向量和矩阵的复习，总体来说难度不大。\n\n1.向量主要是其点乘和叉乘的两种乘法。\n\n- 点乘能够用于计算向量之间的投影和向量之间的夹角，能够判断两向量是否相近（菲涅尔效果）\n- 而向量投影主要能测量两个方向的距离、分解向量以及确定向前/向后等，这些特性能够运用到确定直角坐标系上（即确定基坐标，就是确定一个基准的感觉）\n- 叉乘能够用于确定向量之间的位置关系，左右、内外等。\n- 确定内外在后续光栅化用的会很多，而确定左右的方向好像没有提及运用？？后续有涉及到的话在回来补坑。\n\n2.矩阵则是其乘法计算的一些计算方法。\n\n- 计算机的图形信息基本都是用矩阵存储的，信息与信息的计算后续也会涉及。这里闫老师主要是稍微复习了一下。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"GAME101_Lecture01学习","url":"/2024/04/14/GAME101-Lecture01学习/","content":"\n# 系列前言\n\n按照计划，应该是要学习unity shader的技术的。\n\nsiki学院有shader和Shader Graph两方面的学习，其中graphics shader后半部分属于付费课程。秉持着白嫖的心理，想要去研究乐乐老师的《Unity Shader 入门精要》。\n\n乐乐老师的书从评论来说，适合对计算机图形学有一定了解的人。于是根据评论的建议，找到闫老师的GAME101系列课程。\n\n计划在本月（5月前），将系列课程学完，并完成所有的作业。\n\n学习是永无止境的，共勉~\n\n# 笔记\n\n发现的一些好的参考笔记，都放在下面：\n\n[02_Review Of Linear Algebra (yuque.com)](https://www.yuque.com/u21084722/hmh07m/ypaui9)\n\n# 计算机图形学介绍\n\nLecture01主要讲授计算机图形学在生活的运用以及闫老师主要讲授的内容。\n\n这门课程主要分别为光栅化、曲线和曲面、光线追踪和动画/模拟这四个方面的内容。\n\n## 计算机图形学与计算机视觉\n\n可以认为，涉及到一些推测、猜测等方向的，归纳为计算机视觉领域。\n\n以下是老师关于两个领域之间的一个关系图。\n\n![image-20240414212812143](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/14/20240414212812.png)\n\n\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"Shader学习（二）：vs配置","url":"/2024/04/13/Shader学习（二）：vs配置/","content":"\n# Unity中vs的配置\n\n扩展>管理扩展 搜索“Shader”，下载ShaderlabVS插件既可。\n\n注意要将vs关闭再重开。\n\n# 后记\n\n- 后来发现unity这两年已经有了更新的Shader Graph，开始有点纠结是否要继续学习shaderLab还是转战Shader Graph。。。\n- 最后打算还是先学图形学基础，学完对于unity Shader的学习应该会有更多的认识。无论是ShaderLab还是Shader Graph的学习，打算先放一放。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["shader"],"categories":["computerStudy"]},{"title":"Shader学习（一）：基本概念","url":"/2024/04/13/Shader学习（一）：基本概念/","content":"\n# Shader语言\n\n- 计算机的图形渲染，主要由OpenGL或DirectX来完成。\n\n- OpenGl使用的是GLSL sharder语言，DirectX使用的是HLSL sharder语言。\n- 英伟达公司出的CG语言具有跨平台的特性，能够在两个平台上都适用。\n- unity三种Shader语言都可以运行。\n\n# Unity Shader的分类\n\nunity中使用的是ShaderLab编写。ShaderLab是对三种语言进行了重新封装。unity中的Shader分为以下的三类。\n\n## 表面着色器（Surface Shader）\n\n表面着色器是unity对一些Shader进行了封装，比普通的shader书写简单。\n\n可以认为表面着色器是对顶点/片元着色器的封装，实际编译的时候，表面着色器会被转成顶点/片元着色器。\n\n当光源较多时，适合使用表面着色器，unity的表面着色器已经处理了很多的光照细节。\n\n## 顶点/片元着色器（Vertex/Fragment Shader）\n\n基本的着色器。\n\n实现的效果更强大，所有的功能都提供。\n\n## 固定函数着色器（Fixed Function Shader）\n\n在一些旧的设备上特定使用的着色器。目前使用的很少。\n\n\n\n\n\n\n\n\n\n","tags":["shader"],"categories":["computerStudy"]},{"title":"hexo博客搭建","url":"/2024/04/13/hexo博客搭建/","content":"\n# 环境搭建\n\n## 参考文章\n\n搭建环境参考的文章：[【基础篇】hexo博客搭建教程 - huanhao - 博客园 (cnblogs.com)](https://www.cnblogs.com/huanhao/p/hexobase.html)\n\n## 搭建过程中的问题\n\n### cnpm淘宝镜像地址的更换\n\n这是原文中提供的命令和地址：\n\n```\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n在操作过程中，该地址已于2022年6月30日更改：\n\n```\nhttps://registry.npm.taobao.org => https://registry.npmmirror.com\n```\n\n### github配置\n\ngithub为仓库配置ssh时，若本地的ssh文件夹没有config文件，可能会出现配置失败问题。\n\n新建config.txt文件，将下面的命令直接粘贴进去，保存去掉后缀即可\n\n```\nHost github.com\n  Hostname ssh.github.com\n  Port 443\n```\n\n# 图床搭建\n\n环境搭建的大佬也有提及图床的搭建，推荐了Picee。Picee时chrome的插件，电脑主要使用的edge，无意为此专门下载一个chrome，因此在知乎上找到了其他的方法。\n\n## 参考文章\n\n[如何用github搭建图床（亲测有效）_github图床-CSDN博客](https://blog.csdn.net/xdnxl/article/details/129466060)\n\n## 搭建遇到的问题\n\n使用的是picgo。刚开始选择的是最新的beta版本，结果上传不上去。\n\n后来在参考文章里，换成了2.3.1版本。并且根据文章说的，关闭steam++，结果就上传成功了。。。也不知是steam++的问题还是版本的问题。。。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["hexo"],"categories":["computerStudy"]},{"title":"前言","url":"/2024/04/13/前言/","content":"\n第一次按照教程搭建自己的博客，感谢大佬的教程。教程链接：[【基础篇】hexo博客搭建教程 - huanhao - 博客园 (cnblogs.com)](https://www.cnblogs.com/huanhao/p/hexobase.html)\n\n博客用的是hexo搭建的，主题则是github上一位大佬开源的主题：https://github.com/hooozen/hexo-theme-tranquility.git\n\n越学习越发现世界之大，我们只是茫茫人海中小小的一个。大一的时候是在CSDN等上面写的文章，到了大三才想起要自己的博客，也不知会否为时已晚？\n\n但只要想做，什么时候都不算晚吧。\n","tags":["杂项"],"categories":["life"]}]