[{"title":"unity实现模拟鼠标测量距离","url":"/2024/04/18/unity实现模拟鼠标测量距离/","content":"\n# 思路分析\n\n做项目时，有一个测量距离的功能需要实现：假设屏幕中有四个点ABCD，它们之间可以互相到达。提前设置好了邻接矩阵以及他们之间的路径长度。现在需要用鼠标模拟点与点之间的测量过程。\n\n功能有些复杂，自己学艺不精，想出来的方案比较粗糙：\n\n- 首先需要解决\n"},{"title":"算法练习day2","url":"/2024/04/18/算法练习day2/","content":"\n# 有序数组的平方\n\n[代码随想录 有序数组的平方](https://programmercarl.com/0977.有序数组的平方.html)\n\n[力扣 977.有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)\n\n（用时：0.3小时）\n\n这道题很简单，可以用双指针法或者暴力破解。\n\n## 双指针法\n\n本题允许新构建数组，然后返回值可以是新的数组，因此个人认为才会比较简单。但如果不允许构建数组呢？\n\n- 题目提供的是一个有序的升序数组，数组中也会有负数和零。整个数组都平方后，数组的大小趋势应该是从两头向中间递减的，如图：\n  ![image-20240418171625395](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/18/20240418171632.png)\n- 指针head和tail顾名思义，分别从数组的头和尾开始遍历。\n- 在遍历的时候，比较头和尾的平方大小，大的放入新数组的尾部，不断比较放入，即可得到一个新的升序的平方数组。\n- 注意一下新数组是从后往前赋值的，因此新数组的下标初始值应为数组长度-1.\n\n## 暴力破解\n\n暴力破解就更简单了。\n\n- 将原数组按顺序平方后的值放入新数组中。\n- 再对新数组排序既可。\n\n## 代码实现\n\n**暴力破解：**\n\n```c#\n/// <summary>\n/// 暴力破解\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <returns></returns>\npublic int[] SquareOfArrayFun2(int[] nums)\n{\n    int[] ans = new int[nums.Length];\n\n    for (int i = 0; i < nums.Length; i++)\n    {\n        ans[i] = nums[i] * nums[i];\n    }\n\n    Array.Sort(ans);\n\n    return ans;\n}\n```\n\n**双指针法：**\n\n```c#\n/// <summary>\n/// 双指针法\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <returns></returns>\npublic int[] SquareOfArrayFun1(int[] nums)\n{\n    int[] ans = new int[nums.Length];\n    int head = 0, tail = nums.Length - 1, arrIndex = nums.Length;\n    \n    while(head <= tail)\n    {\n        if (nums[head]* nums[head] < nums[tail]* nums[tail])\n        {\n            ans[--arrIndex] = nums[tail] * nums[tail];\n            tail--;\n        }\n        else\n        {\n            ans[--arrIndex] = nums[head] * nums[head];\n            head++;\n        }\n    }\n\n    return ans;\n}\n```\n\n# 长度最小的子数组\n\n[代码随想录 长度最小的子数组](https://programmercarl.com/0209.长度最小的子数组.html)\n\n[力扣 209.长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n\n（用时：0.5小时）\n\n这道题其实难度不高，但是引入了滑动窗口的思想。\n\n\n\n## 滑动窗口\n\n滑动窗口是一个抽象的概念，在不同地方具体是什么都不太也一样。\n\n- 个人认为窗口其实就是一块“区域”，像是数学的“区间”。\n- 所谓滑动，个人认为是这块区域的起始和终点是可变意思，但是起点和终点始终会保持着起点<=终点这个条件（起点和终点的意义也是这样固定了）。\n- 合起来，滑动窗口可以认为就是一段可变的区间，变化的条件、区间要满足的要求都是人定的。利用这个思想，可以解决一些计算机的问题。\n\n（题外话：滑动窗口也让我想起来计网中的那个滑动窗口hhhh，思想都是很互通呢。）\n\n## 滑动窗口法\n\n本题本质其实就是要找数组中连续的数字，这些数字连在一起，可以看成一片“区域”。\n\n- 程序中，可以用两个指针（也不一定是真的指针）表示窗口的起点和终点。让起点和终点按照我们的要求改变，就可以实现查找区域的想法。\n- end指针先向后探索，从start到end这块区域的数相加如果>=target，那么就说明这块区域是符合要求的“子列”。\n- 由于要找最小子列长度，那么单单符合要求并不够，还得比较符合要求的所有子列的长度。此时可以靠start，从目前已经符合要求的start到end的区间中，后移减短子列长度。\n\nstart和end配合操作，总结来说：\n1.**先找到符合要求的子列**\n2.数一定要连续。依次**让起点往后挪，尝试是否有更加“完美”的子列。**\n\n### 重点思考\n\n写的时候，需要重点考虑以下问题：\n\n- 窗口的start如何定义和改变？\n- 窗口的end如何定义和改变？\n\n个人的一些理解：\n\n- 窗口的start如何定义和改变？\n\n  <u>start指针主要是用来在现有符合条件的子列上，缩短“优化”子列长度。</u>\n  <u>start只有在 s(当前子列和)>=Target时，才能start++以后移</u>\n  <u>start能够一直后移，一定是start++后，s(当前子列和)>=Target依旧成立。</u>（不用担心出现start>end而条件还成立的情况。因为s-nums[start]和start++是先后进行的，s的初值是0，target和数组都是正整数，0<正整数。）\n\n- 窗口的end如何定义和改变？\n\n  <u>end指针主要是用于寻找符合条件的子列，不负责“优化”。</u>\n  <u>end只有在找到s(当前子列和)>=Target时，才会停下来，让start“优化”。</u>\n  <u>end的边界条件是数组长度。</u>\n\n### 错误思考\n\n- 本题写的时候，思路上没有什么阻碍，实现上也是。\n- 但在一个地方出了问题：int的最大值。\n- 以前写习惯了，int的最大值直接定成65535，其实不是。\n- C#中可以用int.MaxValue来替代。\n\n## 暴力破解法\n\n暴力破解就是双层循环，遍历出所有的可能。\n\n# 代码实现\n\n**滑动窗口法：**\n\n```c#\n/// <summary>\n/// 滑动窗口法\n/// </summary>\n/// <param name=\"target\"></param>\n/// <param name=\"nums\"></param>\n/// <returns></returns>\npublic int SmallSubarrayFun1(int target, int[] nums)\n{\n    int start = 0, end = 0, subLen = int.MaxValue, s = 0;\n    while(end< nums.Length)\n    {\n        s += nums[end];\n        while (s>=target)\n        {\n            //先判断并更新目前最短的子列长度\n            if (end - start + 1 < subLen)\n            {\n                subLen = end - start + 1;\n            }\n            //接着尝试缩短窗口（start后移）\n            \n            s -= nums[start];\n            start++;\n        }\n        //缩短窗口完毕，继续让end向后探索\n        end++;\n    }\n    if (subLen== int.MaxValue)\n    {\n        return 0;\n    }\n    else\n    {\n        return subLen;\n    }\n}\n```\n\n# 拓展思考\n\n如果Target不一定是正整数或数组里包含负数或0呢？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习"],"categories":["computerStudy"]},{"title":"算法练习day1补充","url":"/2024/04/18/算法练习day1补充/","content":"\n# 前言\n\n昨天第一天时间太赶，没来得及把剩下的一题看了，今天补回来。\n\n# 移除元素\n\n[代码随想录  移除元素](https://programmercarl.com/0027.移除元素.html)\n\n[力扣 27.移除元素](https://leetcode.cn/problems/remove-element/description/)\n\n（用时0.5小时）\n\n这道题的解法有两种，一种是暴力破解，一种是快慢指针法。\n\n注意题目要求空间复杂度是O(1)，这表明需要在同一个数组中进行处理。\n\n## 暴力破解\n\n暴力破解很简单，两层嵌套循环。\n\n- 外层循环用于遍历整个数组，如果找到需要移除的元素，则开启内层循环。\n- 内存循环用来将该需移除元素后面的所有元素向前挪一位（题目要求元素原顺序不可变）。这样的时间复杂度大概是O(n方)\n\n### 注意重点\n\n暴力破解时，有个地方要注意：所有元素移完位置后，外层循环的循环遍历（一般是那个i），要 i-- 。\n\n- i--主要是因为，我们原本在这个第i位上发现他是要移除的，才将后面所有的元素前移一位。\n- 移完后第i位已经不是原来的那个元素了，此时需要再判断移动后的第i位是不是恰好也是要移除的元素\n- 即**可能会有连续几个元素都是要移除的**\n\n## 快慢指针法\n\n快慢指针需要小绕一下。\n\n- 快指针是对整个数组进行探索遍历，慢指针是对新的数组进行赋值遍历\n\n- 如果反应不过来，可以先把慢指针当成一个新的空的数组的指针。快指针对旧的数组进行遍历：\n\n  ​\t1.如果不是需要移除的元素，则利用慢指针加入新数组的空位中，慢指针向后移一位。快指针后移一位。\n\n  ​\t2.如果是需要移除的元素，新数组和慢指针不做处理。快指针后移一位。\n\n- 两个数组的想好了后，一个数组就简单了。只是将两个指针放到了同一个数组上进行处理。慢指针一定会等于或慢于快指针，因此不会出现问题。\n\n### 注意重点\n\n快慢指针法在写的时候，重点要考虑以下几点：（\n\n- arr[fastIndex] != val时，要做什么？\n- arr[fastIndex] = val时，要做什么？\n- return slowIndex？ 还是slowIndex+1？ 还是slowIndex-1？\n\n以下是个人的一些想法：\n\n- nums[fastIndex] != val时，要做什么？\n\n  <u>不等于时，表示该值不用被跳过，slowIndex要让其放入新数组。更新slowIndex，fastIndex继续探索既可。</u>\n\n- nums[fastIndex] = val时，要做什么？\n\n  <u>等于时，表示该值要被跳过，slowIndex不能放入新数组。让fastIndex继续向前探索即可。</u>\n\n- return什么？\n\n  <u>slowIndex始终是等待赋值的下一位，因此只用return slowIndex即可。</u>\n\n## 代码实现\n\n### 暴力破解\n\n```c#\n/// <summary>\n/// 暴力破解法\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <param name=\"val\"></param>\n/// <returns></returns>\npublic int RemoveElementFun2(int[] nums, int val)\n{\n    int cnt = 0;\n    for (int i = 0; i < nums.Length - cnt; i++)\n    {\n        if (nums[i] == val)\n        {\n            for (int j = i + 1; j < nums.Length - cnt; j++)\n            {\n                nums[j - 1] = nums[j];\n            }\n            cnt++;\n            i--;\n        }\n    }\n    return nums.Length - cnt;\n}\n```\n\n### 双指针法\n\n```c#\n/// <summary>\n/// 快慢指针方法\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <param name=\"val\"></param>\n/// <returns></returns>\npublic int RemoveElementFun(int[] nums, int val)\n{\n    int fastIndex, slowIndex;\n    fastIndex = slowIndex = 0;\n\n    while (fastIndex < nums.Length)\n    {\n        if (nums[fastIndex] != val)\n        {\n            nums[slowIndex] = nums[fastIndex];\n            fastIndex++;\n            slowIndex++;\n        }\n        else\n        {\n            fastIndex++;\n        }\n    }\n\n    return slowIndex;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习"],"categories":["computerStudy"]},{"title":"unity游戏中测量结果归一化处理","url":"/2024/04/18/unity游戏中测量结果归一化处理/","content":"\n# 需求分析\n\n在UGUI下，提前知道两点（设为A、B）之间的距离，以及他们的屏幕坐标。\n\n现在想要实现，鼠标从A点出发移动的偏移值映射到两点之间距离的区间中（即将鼠标相对A点的偏移数据处理到AB距离的范围内，以达到模拟真实测量的效果。\n\n（例如：让玩家点击A点后出现，从A点延申到鼠标上有一条线，通过拉线来实现测量的效果。）\n\n时间有点紧迫，也没有细想这样实现的可用性啥的。真诚希望有大佬指教！\n\n# 归一化公式\n\n使用的公式出处：[将数据归一化到任意区间范围的方法_数据 处理到 指定范围内-CSDN博客](https://blog.csdn.net/irober/article/details/115601223)\n\n# 代码实现\n\n**归一化函数：**\n\n```c#\n/// <summary>\n/// 将测量结果归一化\n/// </summary>\n/// <param name=\"min\">样本数据的最小值</param>\n/// <param name=\"max\">样本数据的最大值</param>\n/// <param name=\"left\">区间的左边界</param>\n/// <param name=\"right\">区间的有边界</param>\n/// <param name=\"value\">需要归一化的测量结果</param>\npublic float MeasureNormalization(float min,float max,float left,float right,float value)\n{\n    float temp;\n    if (min>max)\n    {\n        temp = min;\n        min = max;\n        max = temp;\n    }\n    if (left>right)\n    {\n        temp = left;\n        left = right;\n        right = temp;\n    }\n\n    return left + (right - left) / (max - min) * (value - min);\n}\n```\n\n**调用举例：**\n\n```c#\n//将鼠标的坐标转为屏幕坐标系的坐标\nRectTransformUtility.ScreenPointToLocalPointInRectangle( UI的画布RectTransform, 鼠标自己坐标系下的当前坐标, null, out 接收鼠标在屏幕坐标系下的坐标的变量);\n\n//归一化后的结果\nans = MeasureNormalization( 0, AB点屏幕坐标下的距离, 0, AB点认为规定要测量出来的距离, 鼠标在屏幕坐标系下的坐标);\n```\n\n\n\n\n\n","tags":["unity"],"categories":["computerStudy"]},{"title":"unity中鼠标与物体的交互","url":"/2024/04/18/unity中鼠标与物体的交互/","content":"\n# unity内置方法\n\nunity内置的OnMouseOver等方法，原理是利用射线检测。\n\n前提条件一是要有collider，二是摄像机要能够进行射线检测。\n\n- 在做的项目中，有个UGUI的2d物体无法使用OnMouseOver，猜测是因为摄像机实际上不是对着UI的。\n- **OnMouseOver这类方法，不适合对UI的拖拽进行处理，适合对3d物体的拖拽进行处理。**\n\n# unity EventTrigger组件\n\nEventTrigger的使用方法有很多，一是手动添加EventTrigger组件，然后对事件函数进行拖拽。二是可以重写接口。\n\n重写接口时，要注意，IBeginDrawHandler和IEndDrawHandler一定要有IDrawHandler才能实现。\n\n在鼠标拖拽时，UI物体与鼠标相差太远，原因可能是因为Canvas的Scale数值不是1，这时候要么就全调成1，要么就在脚本中除以相应的画布尺寸大小系数。\n\n# 学习视频链接\n\n学习时看的视频链接：【【盘点】Unity常用的三种拖拽方法（内置方法 + 接口 + Event Trigger组件）】 https://www.bilibili.com/video/BV1W541147GK/?share_source=copy_web&vd_source=8332072dc5586e92174abc96d6e4280f\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["unity"],"categories":["computerStudy"]},{"title":"GAME101-Lecture03学习","url":"/2024/04/17/GAME101-Lecture03学习/","content":"\n# 变换引入目的\n\n建模、3D转2D（投影）\n\n![image-20240417214811477](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417214818.png)\n\n# 缩放（变换）\n\n![image-20240417233641105](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233641.png)\n\n![image-20240417233647324](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233647.png)\n\n![image-20240417233701179](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233701.png)\n\n# 反射/对称（变换）\n\n![image-20240417233817350](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233817.png)\n\n# 切变\n\n![image-20240417214916402](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417214916.png)\n\n- 提示:\n- 水平位移在y=0处为0\n- 水平位移在y=1处为a\n- 垂直位移总是0\n\n整体：只是水平方向发生移动，竖直方向没有变化\n\n上面的边：水平方向移动的都是a\n\n中间的位置（y=0.5时）：水平方向移动都是0.5a\n\n总结可以认为，水平位置移动了a*y。x' = x+ay,y'=y，写成矩阵形式就是右下角的样子。\n\n# 旋转（变换）\n\n我们自己规定，任何旋转没有特地说明，都认为是绕着原点(0,0)旋转，旋转方向默认逆时针。\n\n## 旋转矩阵\n\n![image-20240417215439805](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417215439.png)\n\n## 旋转矩阵推导过程\n\n![image-20240417220007752](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417220007.png)\n\n列向量左乘矩阵\n\n- 首先，(x,y)--->(x',y')肯定是x和y分别乘以了某些系数，从而才能达到(x',y')的效果。（前面切变那里的分析过程\n- 按照切变的例子，向量(x',y')可以转化成向量乘矩阵的形式就是闫老师写出的那个ABCD的式子（图中黑色箭头尾端的式子）。此时问题就转化成了解出ABCD的值。\n- 要解矩阵，可以通过到带入特殊值的方式。最上面靠右的图就是闫老师演示的某种特殊情况，(1,0)--->(cosθ,sinθ)，将其带入待解式子即可（图中黑色部分）\n- 要完全解出来四个参数ABCD，找两个特殊解即可。\n\n（弹幕中有补充一般性的问题，闫老师这种解法是可以的）\n\n# 线性变换\n\n![image-20240417221233333](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417221233.png)\n\n如果能把变换写成上图的这种形式（即用矩阵乘以输入的坐标可以得到输出的坐标），这种变换叫做线性变换。\n\n即对于一个变换，用一个矩阵表示。\n\n# 齐次坐标\n\n**引入齐次坐标的主要原因是平移变换比较特殊，简单的表示成前面所需的一个矩阵乘以一个向量的形式，而不是让平移变换成为一个特殊的变换。**\n\n后续的推导起到帮助理解的作用。\n\n## 引入目的\n\n![image-20240417221910780](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417221910.png)\n\n![image-20240417221925820](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417221925.png)\n\n- 平移不能以矩阵形式表示(所以，翻译不是线性变换!)\n- 但我们不希望翻译成为一个特例\n- 是否有一种统一的方式来表示所有的转换?成本是多少\n\n平移的变换主要是加法，看着简单，但是像前面那样，通过矩阵的解法列出的话，会很复杂（如第二幅图）。（弹幕中说，这在线性代数中，叫做非齐次方程）\n\n并且，由于平移的变换中，矩阵乘法后面还要做一个加法，因此平移变换不是线性变换\n\n## 齐次坐标的解决方案\n\n用齐次坐标，通过增加一个数（一个维度）让平移变换写成矩阵乘以向量的形式（其他的线性变换也可以这么写），如下图(x',y',w')的变换：\n\n![image-20240417223038073](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417223038.png)\n\n## 齐次的“保护性”\n\n向量表示的是方向性，向量平移表示的任是同一个向量，这说明向量具有平移不变性。\n\n那么如果有一个向量(x,y,0)，经过矩阵的变换，若想让他不变（依旧是(x+t,y+t,0)）。可以增加一个0（一个维度）保护他。\n\n![image-20240417223410477](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417223410.png)\n\n- 齐次坐标\n- 如果结果的w坐标为1或0，则有效操作\n\n在空间中（二维或三维），向量加上向量（三角形法则）得到一个新的向量。\n\n点减去点，得到新的向量。\n\n点加上向量，点沿着一条线移动，移动到一个新的点上。\n\n点加点的扩充定义：在二维中，当w不等于0，可以让其转成（x/w,y/w,1)，w=1就可以表示成一个二维的点(x/w,y/w)。\n\n因此点加点得到的是这两个点的中点\n\n上述阐述了，最后一位是0，不仅保证了其平移不变性，还能保证在操作下是对的。\n\n\n\n# 仿射变换\n\n![image-20240417224820539](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417224820.png)\n\n图中上方的式子，我们称为仿射变换。\n\n在图中下方的式子中，我们用一个式子（齐次坐标）表示了所有的变换\n\n用齐次坐标去**表示二维的仿射变化**时，可以发现：\n\n- 矩阵的最后一行永远是001\n- 平移永远是写在最后一列的头两个数上\n- 前两列的前两个元素是原来线性变换的部分\n\n# 2D（二维）变换\n\n![image-20240417225121008](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225121.png)\n\n缩放变换中，没有平移，因此最后一列头两个数是00。\n\n旋转变换中，平移和缩放同理。\n\n平移变换中，没有经过线性变换，左上角是单位矩阵1001，有平移因此最后一列头两个数是tx ty。\n\n# 逆变换\n\n![image-20240417225508580](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225508.png)\n\n逆变换在矩阵中，就是乘以逆矩阵。\n\n# 组合变换\n\n![image-20240417225649265](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225649.png)\n\n- 如何才能从左边变换成右边？\n\n![image-20240417225656282](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225656.png)\n\n- 先平移再旋转，发现不可行\n\n![image-20240417225705466](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225705.png)\n\n- 先旋转在平移，发现可行\n\n通过上面的例子，可以知道\n\n- 复杂的变换可以通过简单的变化得到\n- 变换的顺序很重要\n- 这和矩阵的乘法一致，矩阵没有交换律\n\n![image-20240417225940346](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225940.png)\n\n向量默认时一个列矩阵，因此做变换的时候需要从左往右乘。（如图，列矩阵xy1先做旋转再做平移，因此先左乘一个R再左乘一个T）\n\n## 推广\n\n![image-20240417230313249](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417230313.png)\n\n- 仿射变换序列A1、A2、A3,…由矩阵乘法构成\n- 对性能非常重要！\n- 对n个矩阵进行预相乘以获得表示组合变换的单个矩阵\n\n先将前面的矩阵全部乘完，乘完还是一个3\\*3的矩阵。这说明一个3\\*3的矩阵可以表示很复杂的变换。\n\n# 分解变换\n\n![image-20240417230947003](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417230947.png)\n\n- 如何围绕一个给定的点c旋转?\n- 将中心转换为原点\n- 旋转\n- 移动回来\n\n相当于在二维中，图形绕着任意一个点旋转，都可以转换成：先把图形平移使得旋转点与原点重合，再绕原点旋转，然后再把旋转后的图形移回相同的参数\n\n# 3D变换\n\n三维空间的变换，可以类比二维的。\n\n注意区别，三维的点和向量增加一个数（升维）后，并不是四元数，四元数是专门用来表示旋转的。\n\n![image-20240417231500879](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417231500.png)\n\n- 再次使用齐次坐标\n\n![image-20240417231558326](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417231558.png)\n\n最后一行还是0001\n\n平移：依旧是在最后一列\n\n线性变换：左上角的3\\*3矩阵\n\n# 课堂启发\n\n可以把仿射变换写成一个简单的矩阵形式，矩阵表示线性操作和平移操作。\n\n# 课堂问题\n\n闫老师留下来的问题：在三维的变换中，矩阵应用在xyz这个三维点上，是先平移还是先线性变换呢？\n\n解答：可以看前面，2D下仿射变换的式子，是线性变换（矩阵乘以向量）加上平移变换。因此是先线性变换再平移变换。\n\n# 总结\n\n今天讲的是各种变换，前面所有的变换都是以2D为例的，3D其实也是同理。\n\n缩放、对称、旋转等这些变换，能够直接用矩阵乘以向量的形式表示，称为线性变换。\n\n平移不能以矩阵乘以向量表示，并不是平移变换。其形式是矩阵乘以向量加上一个矩阵，可以称之为仿射变换。\n\n如果将平移看作特殊的变化，那又太过麻烦。为了让所有的变换具有统一性，引入了齐次坐标的知识。\n\n齐次坐标能够通过加一个数（升维）的方式，通过齐次坐标来表示仿射变换。其次坐标也可以表示线性变换。\n\n因此，能够用齐次坐标的方式，将所有的变换转变成矩阵与向量的形式。\n\n将单一的变换累加，就是组合变换。组合变换中，变换的顺序很重要。\n\n在组合变换中发现，先将所有的变换矩阵相乘，还是能得到一个矩阵，这说明任何复杂的变换都能用一个矩阵来表示。\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"算法练习day1","url":"/2024/04/17/算法练习day1/","content":"\n# 前言\n\n大二开始定下实践项目的主方向后，对于数据结构、算法这一块基本就是停滞状态了。\n\n选择游戏方向后，unity和C#的实际项目对于算法方面的要求并不多。实习需要去大厂，并且为了进一步提高自己的能力，决定接下来的日子里苦练算法。\n\n以前练习算法这方面，用的都是C、Java这类。用C#写还是头一次，在练习算法的同时，增进自己对C#的使用熟练度，也是一举两得。\n\n接下来的日子，打算跟着卡哥的《算法随想录》刷题。根据http://t.csdnimg.cn/l8b7i，这篇大哥的博客，每天进行练习。自己练习确实得要很大的毅力和决心，希望自己能够坚持下来，共勉~\n\n# 二分查找\n\n[代码随想录 二分查找](https://www.programmercarl.com/0704.二分查找.html)\n\n[力扣 704.二分查找](https://leetcode.cn/problems/binary-search/)\n\n（用时：1.5小时）\n\n写的过程中出现了错误，思考了10分钟无法解决后，找了参考代码进行了纠错。错误如下：\n\n- 错误一：target < arr[mid]写成了target < mid\n- 错误二：写成了递归（也不算是错误，递归也能实现二分查找。但写的混合了递归和非递归，导致写的非常混乱！这也是对递归没有很好的理解。后来理清非递归后，重新写了下递归，一起放在后面了）\n- 错误三：左闭右开时，right = mid写成了right = mid-1\n\n## 错误复盘\n\n**错误一分析：**mid是一个下标，在target是一个值，比较的时候应是拿值比较。这里是对mid和target的关系没有更加深刻的理解，当查找到时，两者关系：target=arr[mid]\n\n**错误二分析：**写成了递归这个错误就emmmm，其实是可以写成递归的。递归之前也一直是迈不过去的坎，导致这里先入为主了。递归是写出来了，但并不是题目格式的要求。。每天的时间有限，第一遍刷更侧重于复习回顾理解，第二遍再拓展深究。\n\n**错误三分析：**\n\n- 卡哥视频二分查找有两个重点，一是while的判断条件，二是if里的判断条件。\n\n- while的判断条件看开闭区间，看left=right是否能取即可。\n\n- if判断条件也是看开闭区间，这里是看left是否能等于区间左侧、right是否能等于区间右侧\n\n  例如，假设  区间为[i,j)   mid=(i+j)/2，left=mid、左闭是可取的，right=mid、右开不可取\n\n  ![image-20240417185239607](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417185239.png)\n\n## 正解\n\n**左闭右闭：**\n\n```c#\n/// <summary>\n/// 左闭右闭\n/// </summary>\n/// <param name=\"arr\"></param>\n/// <param name=\"target\"></param>\npublic int Search1(int[] arr, int target)\n{\n    int mid, left, right;\n    left = 0;\n    right = arr.Length - 1;\n    //左闭右闭，left可以等于right\n    while (left <= right)\n    {\n        mid = (left + right) / 2;\n        if (target < arr[mid])\n        {\n            //右闭，mid可以取右边界，这里不用重复比较右边界，所以减一\n            right = mid - 1;\n        }\n        else if (target > arr[mid])\n        {\n            //左闭，mid可以取右边界，这里不用重复比较左边界，所以加一\n            left = mid + 1;\n        }\n        else\n        {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n\n**左闭右开：**\n\n```c#\n/// <summary>\n/// 左闭右开\n/// </summary>\n/// <param name=\"arr\"></param>\n/// <param name=\"target\"></param>\n/// <returns></returns>\npublic int Search2(int[] arr, int target)\n{\n    int mid, left, right;\n    left = 0;\n    right = arr.Length - 1;\n\n    while (left < right)\n    {\n        mid = (left + right) / 2;\n\n        if (target < arr[mid])\n        {\n            //右开，mid不可以取右边界，这里恰好也不用重复比较右边界，所以不变\n            right = mid;\n        }\n        else if (target > arr[mid])\n        {\n            //左闭，mid可以取右边界，这里不用重复比较左边界，所以加一\n            left = mid + 1;\n        }\n        else\n        {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n\n**尝试写的递归（并不符合题目条件，只是想训练一下自己递归的思路）：**\n\n```c#\n/// <summary>\n/// 左闭右闭，尝试写的递归，加上了left和right\n/// </summary>\n/// <param name=\"arr\"></param>\n/// <param name=\"left\"></param>\n/// <param name=\"right\"></param>\n/// <param name=\"target\"></param>\n/// <returns></returns>\npublic int Search3(int[] arr, int left, int right, int target)\n{\n    int mid;\n    mid = (left + right) / 2;\n    if (left>right)\n    {\n        return -1;\n    }\n    else\n    {\n        if (target < arr[mid])\n        {\n            return Search3(arr, left, mid - 1, target);\n        }\n        else if (target > arr[mid])\n        {\n            return Search3(arr, mid + 1, right, target);\n        }\n        else\n        {\n            return mid;\n        }\n    }\n}\n```\n\n# 后记\n\n今天实在是有点忙，还有一题没写，第二天一起补上呜呜呜。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习 二分查找"],"categories":["computerStudy"]},{"title":"行测_判断推理学习(一)：图形推理_位置规律","url":"/2024/04/16/行测-判断推理学习-一-：图形推理-位置规律/","content":"\n识别特征：元素组成相同\n\n# 考点一：平移\n\n方向：直线(上下、左右、斜对角线)、绕圈(顺逆时针)\n\n常见步数：恒定、递增(等差)\n\n# 考点二：旋转、翻转\n\n1.旋转\n方向：顺时针、逆时针\n常见角度45°、90°、180\n\n2.翻转\n左右翻转:竖轴对称\n上下翻转:横轴对称\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["行测 判断推理 图形推理 位置规律"],"categories":["civilStudy"]},{"title":"GAME101_Lecture02学习","url":"/2024/04/16/GAME101-Lecture02学习/","content":"\n# 向量复习\n\n图形学中，未作特殊规定的向量，缺省值（默认值）都是列\n\n![image-20240416184124364](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416184237.png)\n\n- 点积\n- 叉积\n- 正交基与坐标系\n\n\n\n## 点乘\n\n### 点乘基本知识\n\n![image-20240416172958213](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173005.png)\n\n左下角的公式中：点乘可以快速得到两个向量之间的夹角，特别是在两个向量都只是方向的时候。\n\n右下角的公式中：只要我们做一个反余弦，那就可以得到两个向量之间的夹角。 \n\n![image-20240416181413864](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416181414.png)\n\nA表示一个向量（默认列向量），AT是A向量的转置\n\nA的值可以用红色公式表示。\n\n\n\n### 直角坐标系的点积\n\n![image-20240416173414055](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173414.png)\n\n#### 图形学应用\n\n![image-20240416173442667](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173442.png)\n\n- 求两个向量之间的夹角(如光源与表面夹角的余弦)\n- 求一个向量在另一个向量上的投影\n\n\n\n### 投影点积\n\n![image-20240416173507601](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173507.png)\n\n点乘可以把一个向量任意的进行垂直与平行的分解\n\n上图计算向量b向量a的投影时，b的投影向量  = 向量b的长度 · cosθ · 向量a\n\n#### 图形学作用\n\n![image-20240416173534623](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173534.png)\n\n- 测量两个方向的距离\n- 分解向量\n- 确定向前/向后\n\n图形学中，可以计算两个向量或两个方向多么接近。主要通过比较点乘结果，可以判断接近还是远离这两个方向。\n\n![image-20240416173926813](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173926.png)\n\n向量的点乘还可以得到一个前与后的信息。\n\n如图假设向量a给定了某个方向，从a的起点向上为前，向下为后。\n\n向量a与b的点乘会为正数表示其的方向是指向a的前方。向量c反之。\n\n若向量a与某个向量的点乘为0，那么这个向量与向量a垂直。\n\n同理，前面说到点乘可以判断接近还是原理。向量b与向量a越来越远，那么两者的点乘还会越来越等于0（即垂直），随后更远就是与a的方向相反，直到点乘变成-1（此时b与a完全相反）。\n\n\n\n判断两个向量是否接近，其中一个应用——菲涅尔效果（看的角度和面的法线是否重合问题。越重合，说明面是对着相机的。否则面就越侧面（越亮），直到变成负数就是背面了（暗色））\n\n\n\n## 叉乘\n\n### 叉乘基本知识\n\n![image-20240416180608714](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416180608.png)\n\n- 叉积与两个初始向量正交\n- 右手定则确定方向\n- 在构造坐标系中很有用(以后)\n\n右手螺旋定则（有些地方会用左手），可以判断\n\n![image-20240416181639954](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416181640.png)\n\n左侧的公式中，如果在三维坐标系中，x叉乘y是z，那么这个坐标系就是一个右手坐标系。\n\n右侧的公式中，注意向量叉乘自己是0向量。并且叉乘只有反交换律。\n\n![image-20240416182118165](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416182118.png)\n\n在下方的公式，是向量可以写成矩阵的形式，然后向量的叉乘可以转换成矩阵乘以向量\n\n### 图形学的应用\n\n![image-20240416182340467](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416182409.png)\n\n- 确定左/右\n- 确定内部/外部\n\n在图形学中，叉乘一是判断左和右，另一个是判断内和外。\n\n![image-20240416182759510](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416182759.png)\n\n在左图中，向量a叉乘向量b、得到z是正的；向量b叉乘向量a、得到的z是负的。这两种都能证明b在a的左侧。\n\n在右图中，ABC的排布是逆时针，AB叉乘AP和BC叉乘AP、AC叉乘AP的z都是向外的（即AP都在所有边的左侧），这能说明P在ABC的中间。\n\nABC的排布变成顺时针也同理。（此处是对三角形做光栅化的基础，可以判断三角形覆盖了那些像素。若值等于0，即该像素刚好在三角形的边上，那么就自己定义）\n\n## 正交基与坐标系\n\n通过这些向量的乘法，就可以定义坐标系。定义坐标系可以把任意一个向量分解到三个轴上（利用点积算投影，然后用投影分解）\n\n![image-20240416190717359](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416190717.png)\n\n如图，假设将uvw设为一个三维坐标系的坐标轴，它们都是单位向量。\n\n假设有一个向量p。我们可以用投影的方式投影到坐标轴上，直接用点乘的结果就可以立刻得到投影的长度。原因解释如下：\n\n- 先假设向量p投影到u轴上，此时计算向量p在向量u上的投影向量。\n- p在向量u上的投影向量  = 向量p的长度 · cosθ · 向量u\n- 向量p点乘向量u=p的长度 × u的长度 × cosθ。\n- 此时u为单位向量，长度为1。\n- 那么，向量p点乘向量u = u的长度 × cosθ，正好就是其投影长度。\n- （picgo上传出了问题，后面再补坑吧呜呜呜）![image-20240416200321655](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417184348.png)\n\n# 矩阵复习\n\n![image-20240416190822580](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416190822.png)\n\n- 神奇的2D阵列，在每一个CS课程中萦绕\n- 在图形学中，广泛用于表示变换翻译、旋转、剪切、缩放(下一讲更详细)\n\n## 矩阵乘积知识\n\n![image-20240416191421852](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416191421.png)\n\nm\\*n的矩阵 乘以 n\\*p的矩阵 = m\\*p的矩阵\n\n矩阵乘法运算，黑色框框和蓝色框框分别是两个例子：\n\n- 黑色框框的？，是在结果的第一行第二列，那么就去第一个矩阵中找第一行，第二个矩阵中找第二列，(1\\*6)+(3\\*7) = 27\n- 蓝色框框同理，(5\\*4)+(2\\*3) = 26\n\n![image-20240416192400862](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416192400.png)\n\n矩阵没有任何的交换率。结合律比较有用。\n\n![image-20240416192852730](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416192852.png)\n\n- 将向量视为列矩阵(mx1)\n- 转换点的关键(下一讲)\n- 官方剧透:关于y轴的2D反射\n\n 始终认为，矩阵在左边，向量在右边。 \n\n![image-20240416192945749](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416192945.png)\n\n矩阵的变换（转置）\n\n![image-20240416193013912](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416193014.png)\n\n# 矩阵和向量\n\n![image-20240416193056657](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416193056.png)\n\n向量在矩阵形式上的计算。\n\n# 总结\n\n这节课主要是对线性代数中向量和矩阵的复习，总体来说难度不大。\n\n1.向量主要是其点乘和叉乘的两种乘法。\n\n- 点乘能够用于计算向量之间的投影和向量之间的夹角，能够判断两向量是否相近（菲涅尔效果）\n- 而向量投影主要能测量两个方向的距离、分解向量以及确定向前/向后等，这些特性能够运用到确定直角坐标系上（即确定基坐标，就是确定一个基准的感觉）\n- 叉乘能够用于确定向量之间的位置关系，左右、内外等。\n- 确定内外在后续光栅化用的会很多，而确定左右的方向好像没有提及运用？？后续有涉及到的话在回来补坑。\n\n2.矩阵则是其乘法计算的一些计算方法。\n\n- 计算机的图形信息基本都是用矩阵存储的，信息与信息的计算后续也会涉及。这里闫老师主要是稍微复习了一下。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"GAME101_Lecture01学习","url":"/2024/04/14/GAME101-Lecture01学习/","content":"\n# 系列前言\n\n按照计划，应该是要学习unity shader的技术的。\n\nsiki学院有shader和Shader Graph两方面的学习，其中graphics shader后半部分属于付费课程。秉持着白嫖的心理，想要去研究乐乐老师的《Unity Shader 入门精要》。\n\n乐乐老师的书从评论来说，适合对计算机图形学有一定了解的人。于是根据评论的建议，找到闫老师的GAME101系列课程。\n\n计划在本月（5月前），将系列课程学完，并完成所有的作业。\n\n学习是永无止境的，共勉~\n\n# 笔记\n\n发现的一些好的参考笔记，都放在下面：\n\n[02_Review Of Linear Algebra (yuque.com)](https://www.yuque.com/u21084722/hmh07m/ypaui9)\n\n# 计算机图形学介绍\n\nLecture01主要讲授计算机图形学在生活的运用以及闫老师主要讲授的内容。\n\n这门课程主要分别为光栅化、曲线和曲面、光线追踪和动画/模拟这四个方面的内容。\n\n## 计算机图形学与计算机视觉\n\n可以认为，涉及到一些推测、猜测等方向的，归纳为计算机视觉领域。\n\n以下是老师关于两个领域之间的一个关系图。\n\n![image-20240414212812143](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/14/20240414212812.png)\n\n\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"Shader学习（二）：vs配置","url":"/2024/04/13/Shader学习（二）：vs配置/","content":"\n# Unity中vs的配置\n\n扩展>管理扩展 搜索“Shader”，下载ShaderlabVS插件既可。\n\n注意要将vs关闭再重开。\n\n# 后记\n\n- 后来发现unity这两年已经有了更新的Shader Graph，开始有点纠结是否要继续学习shaderLab还是转战Shader Graph。。。\n- 最后打算还是先学图形学基础，学完对于unity Shader的学习应该会有更多的认识。无论是ShaderLab还是Shader Graph的学习，打算先放一放。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["shader"],"categories":["computerStudy"]},{"title":"Shader学习（一）：基本概念","url":"/2024/04/13/Shader学习（一）：基本概念/","content":"\n# Shader语言\n\n- 计算机的图形渲染，主要由OpenGL或DirectX来完成。\n\n- OpenGl使用的是GLSL sharder语言，DirectX使用的是HLSL sharder语言。\n- 英伟达公司出的CG语言具有跨平台的特性，能够在两个平台上都适用。\n- unity三种Shader语言都可以运行。\n\n# Unity Shader的分类\n\nunity中使用的是ShaderLab编写。ShaderLab是对三种语言进行了重新封装。unity中的Shader分为以下的三类。\n\n## 表面着色器（Surface Shader）\n\n表面着色器是unity对一些Shader进行了封装，比普通的shader书写简单。\n\n可以认为表面着色器是对顶点/片元着色器的封装，实际编译的时候，表面着色器会被转成顶点/片元着色器。\n\n当光源较多时，适合使用表面着色器，unity的表面着色器已经处理了很多的光照细节。\n\n## 顶点/片元着色器（Vertex/Fragment Shader）\n\n基本的着色器。\n\n实现的效果更强大，所有的功能都提供。\n\n## 固定函数着色器（Fixed Function Shader）\n\n在一些旧的设备上特定使用的着色器。目前使用的很少。\n\n\n\n\n\n\n\n\n\n","tags":["shader"],"categories":["computerStudy"]},{"title":"hexo博客搭建","url":"/2024/04/13/hexo博客搭建/","content":"\n# 环境搭建\n\n## 参考文章\n\n搭建环境参考的文章：[【基础篇】hexo博客搭建教程 - huanhao - 博客园 (cnblogs.com)](https://www.cnblogs.com/huanhao/p/hexobase.html)\n\n## 搭建过程中的问题\n\n### cnpm淘宝镜像地址的更换\n\n这是原文中提供的命令和地址：\n\n```\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n在操作过程中，该地址已于2022年6月30日更改：\n\n```\nhttps://registry.npm.taobao.org => https://registry.npmmirror.com\n```\n\n### github配置\n\ngithub为仓库配置ssh时，若本地的ssh文件夹没有config文件，可能会出现配置失败问题。\n\n新建config.txt文件，将下面的命令直接粘贴进去，保存去掉后缀即可\n\n```\nHost github.com\n  Hostname ssh.github.com\n  Port 443\n```\n\n# 图床搭建\n\n环境搭建的大佬也有提及图床的搭建，推荐了Picee。Picee时chrome的插件，电脑主要使用的edge，无意为此专门下载一个chrome，因此在知乎上找到了其他的方法。\n\n## 参考文章\n\n[如何用github搭建图床（亲测有效）_github图床-CSDN博客](https://blog.csdn.net/xdnxl/article/details/129466060)\n\n## 搭建遇到的问题\n\n使用的是picgo。刚开始选择的是最新的beta版本，结果上传不上去。\n\n后来在参考文章里，换成了2.3.1版本。并且根据文章说的，关闭steam++，结果就上传成功了。。。也不知是steam++的问题还是版本的问题。。。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["hexo"],"categories":["computerStudy"]},{"title":"前言","url":"/2024/04/13/前言/","content":"\n第一次按照教程搭建自己的博客，感谢大佬的教程。教程链接：[【基础篇】hexo博客搭建教程 - huanhao - 博客园 (cnblogs.com)](https://www.cnblogs.com/huanhao/p/hexobase.html)\n\n博客用的是hexo搭建的，主题则是github上一位大佬开源的主题：https://github.com/hooozen/hexo-theme-tranquility.git\n\n越学习越发现世界之大，我们只是茫茫人海中小小的一个。大一的时候是在CSDN等上面写的文章，到了大三才想起要自己的博客，也不知会否为时已晚？\n\n但只要想做，什么时候都不算晚吧。\n","tags":["杂项"],"categories":["life"]}]