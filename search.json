[{"title":"GAME101-Lecture07学习","url":"/2024/05/15/GAME101-Lecture07学习/","content":"\n# 前言\n\n今天主要讲shading（着色）。在讲着色前，要先讲图形中三角形出现遮挡问题的方法（深度缓存或缓冲）。\n\n先采样再模糊错误：对信号的频谱进行翻译（在这期间会有频谱的混叠），采样就是对这个信号进行截断。此时会发现混叠的信号还是混叠的。\n\n[Lecture 07 Shading 1 (Illumination, Shading and  Graphics Pipeline)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1X7411F744/?p=7&spm_id_from=pageDriver&vd_source=6917f5c8bfecd60a5beb0fffbc41a920)\n\n# 光栅化内容\n\n## 画家算法\n\n![image-20240515142326687](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515142333.png)\n\n先给远处的东西画好（做光栅化），然后再给近处的做。这样就可以得到一个处理了遮挡的结果的“画”。\n\n例如画一个正方体，按照后、左、下、右、上、前的顺序画，就可以得到一个正方体。\n\n但是如果画的顺序改一改，可能会出现不同的效果。这是因为左、下、右、上这几个面到我们眼睛的距离在我们看来都是差不多的（视点到面的距离，又叫“深度”）\n\n![image-20240515142424665](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515142424.png)\n\n- 需要深度排序(对于n个三角形为0(n log n))可以具有无法解析的深度顺序\n\n因此实际中，不能用画家算法。\n\n## 深度缓存（缓冲）\n\n由于不能使用画家算法，因此引入深度缓存的算法。\n\n### 概念\n\n![image-20240515142619909](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515142619.png)\n\n- 这是最终胜出的算法。\n\n- idea：\n\n  存储当前最小值。\n\n  每个样本的Z值(像素)需要一个额外的缓冲区用于深度值\n\n  ​\t-帧缓冲存储器存储颜色值\n  ​\t-深度缓冲区(z缓冲区)存储深度\n\n- 重要:为简单起见，我们假设Z总是正数\n  (较小的z->更近，较大的z->更远)\n\n图形学中，在渲染成品的图像时，会额外生成一个深度图/深度缓存（只存任何一个像素他所看到的最浅的深度信息）\n\n### 算法（做法）\n\n![image-20240515143326188](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515143326.png)\n\n一开始我们认为所有记录深度的点都是无限远的。\n\n![image-20240515143429228](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515143429.png)\n\n数字越小代表越近，近的会把远的遮挡。\n\n#### 复杂度\n\n![image-20240515143700551](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515143700.png)\n\n- 以不同的顺序画三角形?\n- 最重要的可见性算法：在所有GPU的硬件中实现\n\n我们认为每个三角形中有常数个像素，然后又n个三角形，那么复杂度就是0(n)（个人认为这里就有点离谱了，算法的复杂度要是这么算的话，那就所有都是On了。。。。。不过闫老师补充了下一般一个三角形会覆盖100个左右的像素，那就也行）\n\n假设不会出现两个不同的三角形在一个像素上有同样的深度（在图形学中，这些数字大多都是用浮点型来表示，这意味着总会有些误差，这也因此浮点型的判断相同十分困难，尤其时两个经过运算得来的浮点型更加不可能相同），紫色和红色三角形画的**顺序不一样，结果也是一样的**。\n\n# 知识回顾\n\n![image-20240515144717270](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515144717.png)\n\n到目前为止，我们的学习到的内容：模型变换->坐标系变换->投影变换->视口变换->光栅化\n\n![image-20240515144931248](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515144931.png)\n\n# 着色（Shading）\n\n对不同的物体有不同的材质。\n\n## Blinn-Phong模型\n\nBlinn-Phong反色模型是一款着色模型。\n\n![image-20240515151409991](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515151410.png)\n\n- 镜面高光\n- 漫反射\n- 环境照明\n\n## 定义\n\n![image-20240515151557873](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515151557.png)\n\n- 在特定阴影点处反射到摄像机的计算机光\n- 输入：\n  观察者方向，v\n  表面法向，n\n  光的方向，I(为许多光的每一个)\n  表面参数(颜色、光泽度等)\n\n![image-20240515151740156](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515151740.png)\n\n目前所说的着色不考虑物体的存在，先不考虑关系打在物体后环境的变化（即没有阴影），只看光找过来物体表面的情况。着色具有着色性。\n\n## 漫反射(Diffuse Reflection)\n\n![image-20240515152143011](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515152143.png)\n\n- 光均匀地向各个方向散射\n- 所有观看方向的表面颜色相同\n\n**当一个光线会到达某个点，然后这个光线会被均匀的反射出去，这就叫漫反射。**\n\n### 能量的接收\n\n![image-20240515152224381](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515152224.png)\n\n- 但是接收到多少光(能量)呢?\n  一朗伯余弦定律\n- 立方体的顶面接受一定量的光\n- 60°旋转立方体的顶面拦截了一半的光线\n- 一般来说，单位面积的光与cos 0=l·n成正比（**朗伯余弦定律**）\n\n其实就是光通量。\n\n此时就可以算出，这个着色点接收到的光的能量。\n\n### 能量的发射\n\n![image-20240515153203920](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515153204.png)\n\n假设一个点光源。任何时刻，点光源辐射到四面八方。\n\n一个单位的距离上，光的强度为I。那么在距离为r时，强度为I/r<sup>2</sup>\n\n光传播的能量和距离成反比。\n\n此时就可以通过物体距点光源的距离，算出来点光源发送到该物体表面的光的能量。\n\n### 漫反射的能量\n\n![image-20240515154037796](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515154037.png)\n\n- L<sub>d</sub>：漫反射光\n- k<sub>d</sub>：传播系数（颜色)\n- (I/r<sup>2</sup>)：能量到达阴影点\n- max(0,n·l)：阴影点接收的能量\n\n向量点乘(n·l)<0时，表示这个光线从下面打向了物体的表面，此时是没有任何物理意义的（也可以认为我们一般是不会考虑物体内部有光源向外的），因此不考虑。所以这里要用max。\n\n这个shadingPoint是会吸收一部分的光/颜色，它会有一定的吸收率，我们就定义一个系数k<sub>d</sub>。\n![image-20240515154805217](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/15/20240515154805.png)\n\n# 总结\n\n本节课讲的东西比起前面来说，难度直线下降！\n\n今天主要讲着色，讲着色前补充了前面光栅化深度缓存的知识。\n\n光栅化内容中，首先讲解了画家算法的思想。由于画家算法无法很好的满足计算机图形学的需求，因此引入深度缓存的概念。\n\n- 每个导出的图像都有一张对应的深度图，这个深度图记录着所有像素的深度信息。\n- 此外还讲了深度缓存算法的实现方法，其本质就是一个双重循环。\n\n着色部分通过Blinn-Phong反色模型引入漫反射、高光等显示中光照的效果情况。\n\n- 主要讲了物体漫反射中，光的能量问题。\n- 着色点平面与光发现的角度可以得到着色点对光能量接收的情况。\n- 光源与物体的距离可以得到着色点处光能量的发射状况。\n- 通过光能量的接收和发射状况，我们就可以量化漫反射的能量。\n\n\n\n\n\n\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"git的使用","url":"/2024/05/15/git的使用/","content":"\n# git的初始化\n\n## git配置\n\n在本地配置git的账号：\n\n```\ngit config --global user.name \"Your Name\"\ngit config --global user.email your@email\n```\n\n## 配置SSH\n\n要让远程仓库和本地仓库连接起来， 其中一个方法就是配置SSH。\n\nSSH需要通过命令在本地生成密钥：\n\n```\nssh-keygen -t rsa -C \"邮箱\"\n```\n\n将上面的密钥复制，然后粘贴到远程仓库网站上的SSH公钥设置即可。\n\n配置成功后，即可通过仓库的SSH地址进行操作了。\n\n# git的基本使用\n\n**先用下面的命令克隆远程仓库下来**\n\n```\ngit clone <仓库SSH地址>\n```\n\n\n\n**克隆下来后，可能是一个文件夹，要cd一下**\n\n```\ncd <repo-name>\n```\n\n\n\n**查看仓库内所有文件的信息**\n\n```\ngit status\n```\n\n\n\n**增加/修改了仓库。**\n\n这一步是将文件由工作区提交到暂存区。\n\n- 添加所有变动了的文件\n\n  ```\n  git add .\n  ```\n\n- 修改所有的文件\n\n\n\n**提交到版本库**\n\n这一步是将文件由暂存区提交到版本库上，同时添加版本记录。\n\n```\ngit commit -m \"XXXXX\"\n```\n\n\n\n**将版本库的内容提交推送至远端**\n\n```\ngit push\n```\n\n\n\n# git大文件上传\n\n今天有个项目的单个文件200M左右，被git限制了。查找发现，可以用git lfs进行大文件的传输，步骤也很简单。\n\n先**在项目根目录下下载lfs：**\n\n```\ngit lfs install\n```\n\n接着增加.gitattributes文件：\n\n```\ngit add .gitattributes\n```\n\n然后让lfs记录大文件的后缀即可（这里的XXX就是看看上传的那个很大的文件的后缀）：\n\n```\ngit lfs track \"* .XXXX\"\n```\n\n然后正常的add、commit和push即可。\n\n","tags":["git"]},{"title":"算法练习day8","url":"/2024/05/14/算法练习day8/","content":"\n# 反转字符串\n\n[代码随想录 0344.反转字符串](https://programmercarl.com/0344.反转字符串.html#算法公开课)\n\n[344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/description/)\n\n（用时：0.05小时）\n\n## 思路\n\n这道题很简单也很经典。\n\n字符串的反转方法有很多，我这里是用for循环通过数组长度和下标计算来交换。\n\n写这道题时逻辑不难，后面涉及到指定区域的翻转后，脑子就跟不上了。。。后面就直接用双指针了。。\n\n## 代码实现\n\n```c#\npublic class ReverseString\n{\n    public void ReverseStringFun(char[] s)\n    {\n        char temp;\n        for(int i=0;i<s.Length/2;i++)\n        {\n            temp = s[i];\n            s[i] = s[s.Length-1-i];\n            s[s.Length - 1 - i] = temp;\n        }\n    }\n}\n```\n\n# 反转字符串II\n\n[代码随想录 0541.反转字符串II](https://programmercarl.com/0541.反转字符串II.html#算法公开课)\n\n[541. 反转字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string-ii/description/)\n\n（用时：3小时）\n\n## 思路\n\n这道题主要是要理解题意。。\n\n题目要求我们按2K为一组，每组的前K个元素进行翻转。\n\n- 这意味着一般的情况应该是K个翻转K个不翻转\n\n- 当元素无法达到2K时：\n\n  若>K，则翻转K个元素\n  若<K，则翻转剩余所有的元素\n\n  ![image-20240514104414238](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/14/20240514104421.png)\n\n## 错误\n\n这道题在交换指定区域的数组元素中卡住，对自己更无语了\n\n上一道题是用for循环，然后直接通过计算一下子秒掉了，但是这道题中，初始值和终点值有变化，<u>写多了看多了逻辑就混乱了</u>。。。。于是用回了while双指针。。。\n\n## 代码实现\n\n```c#\npublic char[] ReserseChars(int start,int end, char[] chars)\n{\n    char temp;\n    while(start<end)\n    {\n        temp = chars[start];\n        chars[start] = chars[end];\n        chars[end] = temp;\n        start++;\n        end--;\n    }\n    return chars;\n}\n\npublic string ReverseStr(string s, int k)\n{\n    char[] ans =  s.ToArray<char>();\n    for (int i=0;i<s.Length;i+=2*k)\n    {\n        //剩余的少于k个\n        if (i+k>ans.Length)\n        {\n            ans = ReserseChars(i, ans.Length-1, ans);\n        }\n        //大于k个小于2k个\n        else\n        {\n            ans = ReserseChars(i, i + k-1, ans);\n        }\n    }\n    return new string(ans);\n}\n```\n\n# 翻转字符串里的单词\n\n[代码随想录 0151.翻转字符串里的单词](https://programmercarl.com/0151.翻转字符串里的单词.html#算法公开课)\n\n[151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/description/)\n\n（用时：2小时）\n\n## 思路\n\n这道题是对字符串中的单词翻转，意思就是单词的顺序翻转，单词本身里面的字母不要翻转。\n\n要实现有很多种方法，又看到一位大佬用了字典（键值对）。我刚开始也想着可以用分割字符串的方法。\n\n但训练算法时还是不要用这么多库函数。卡哥也要求我们在原字符串上操作。\n\n我们可以先将整体的字符串翻转，这样单词的顺序就达到了我们的效果。但是单词的字母也翻转了，我们逐一对单个单词再翻转一次即可。此外还要消减空格，让每个单词之间只有一个空格。\n\n## 重点\n\n个人感觉这道题主要是思路上的问题。卡哥给的思路很清晰，所以实现起来没有出什么问题。\n\n但是自己想的时候是很混乱的，判断来判断去的。。。思路真的很重要啊！\n\n## 错误\n\n写的过程中，犯了一些错误：\n\n1. 去除空格和翻转单词的实现。\n2. 最终输出的字符串，后面多余了很多重复的字母们。\n3. 使用ReserseChars时数组越界\n4. 分别在去除空格和翻转单词的for循环中，while循环的条件数组越界了。\n\n个人理解如下：\n\n- <u>去除空格和翻转单词的实现错误。</u>\n\n  这道题里，去除空格和翻转单词分开做比较好，这样不容易乱。\n\n- <u>最终输出的字符串，后面多余了很多重复的字母们。</u>\n\n  后面重复的都是新字符串中无用的空间。因为新的字符串的长度没有记录下来，导致后面翻转单词时依旧遍历原本字符串的长度，把后面多余的“垃圾”也翻转，然后输出了。\n  \n- <u>使用ReserseChars时数组越界</u>\n\n  这是在输入begin和end的时候，fast此时在前面的while中，可能是=len了，此时ans[fast]会越界。\n\n  而且这个单词有效的范围也是slow到fast-1，fast本身停止的条件就是当fast指向不属于该单词的范围的时候（即越界或者遇到空格的单词结束。）\n\n- <u>分别在去除空格和翻转单词的for循环中，while循环的条件数组越界了。</u>\n\n  这是因为在for中间，“擅自”让i/fast向前探索，只有两种情况下会让它停下来：\n  一是找到指定要求的地方了（比如找到不属于单词的部分了）\n  二是到了末尾，这个单词刚好是最后一个。\n\n  第一种情况用ans[fast或i]!=' '既可，但第二种情况下的ans是会越界的！因此要有一个判断其是否超出范围的条件，且这个条件要放在第一个条件前判断。\n\n## 代码实现\n\n这道题是剑指Offer的题目。力扣上已经下架了，卡哥的卡玛网上没有C#的检测，也没有专门去写C++的版本。。。\n\n```c#\npublic char[] ReserseChars(int start, int end, char[] chars)\n{\n    char temp;\n    while (start < end)\n    {\n        temp = chars[start];\n        chars[start] = chars[end];\n        chars[end] = temp;\n        start++;\n        end--;\n    }\n    return chars;\n}\n\n\npublic string Reserse(string s,int k)\n{\n    char[] ans = ReserseChars(0, s.Length - 1, s.ToArray<char>());\n\n    ans = ReserseChars(0, k-1, ans);\n    ans = ReserseChars(k - 1, s.Length - 1, ans);\n\n    return new string(ans);\n}\n```\n\n# 替换数字（空格）\n\n[代码随想录 0054.替换数字](https://programmercarl.com/kamacoder/0054.替换数字.html#思路)\n\n（用时：1小时）\n\n这道题没有对字符串的翻转操作了，本题主要考察的是插入删除（个人感觉）。\n\nC#中对string的扩张不用库函数太麻烦了，因此就不写卡哥教的双指针的方法了，实现用了库函数。卡哥的方法有分析了一下，接下来二刷试试用C++实现吧。\n\n## 代码实现\n\n```c#\npublic string Replace(string s)\n{\n    string number = \"number\";\n    int index = 0;\n\n    while(index<s.Length)\n    {\n        if (s[index]>='0' && s[index]<='9')\n        {\n            s = s.Remove(index, 1);\n            s = s.Insert(index, number);\n        }\n        index++;\n    }\n    return s;\n}\n```\n\n# 右旋字符串\n\n[代码随想录 0055.右旋字符串](https://programmercarl.com/kamacoder/0055.右旋字符串.html)\n\n（用时：1小时）\n\n只能说太牛了卡哥的思路！写完上一题过来还是没有想到这个想法：**整体翻转+局部翻转**\n\n思路和翻转单词那里一样。\n\n同样也是剑指Offer。\n\n## 代码实现\n\n```c#\npublic char[] ReserseChars(int start, int end, char[] chars)\n{\n    char temp;\n    while (start < end)\n    {\n        temp = chars[start];\n        chars[start] = chars[end];\n        chars[end] = temp;\n        start++;\n        end--;\n    }\n    return chars;\n}\n\n\npublic string Reserse(string s,int k)\n{\n    char[] ans = ReserseChars(0, s.Length - 1, s.ToArray<char>());\n\n    ans = ReserseChars(0, k-1, ans);\n    ans = ReserseChars(k - 1, s.Length - 1, ans);\n\n    return new string(ans);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习"],"categories":["computerStudy"]},{"title":"算法练习day7","url":"/2024/05/09/算法练习day7/","content":"\n# 四数相加II\n\n[代码随想录 0454.四数相加II](https://programmercarl.com/0454.四数相加II.html#算法公开课)\n\n[454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/description/)\n\n（用时：0.5小时）\n\n## 思路\n\n本道题是需要在四个数组中，各找一个数，这些数加起来能够等于0，那么就是答案元组。各个数组的数字元组中的位置是固定的，0001和1000是不同的答案。\n\n普通的解法一般是四重循环遍历，逻辑简单粗暴就不再赘述。\n\n这道题可以用哈希表配合进行求解。\n\n- 先算前两个数组元素相加的结果，将他们的结果存入哈希表中，这里是一个二重循环。\n\n  对于前两个数而言，1 2和2 1他们的和虽然都是3，但是情况是不一样的，属于3的情况出现了两次。题目要输出答案元组的个数，因此选择使用hashset。\n\n- 接着再算后两个数组元素相加结果，通过hashset查找前两个数的和中符合条件的，组成一个完整的答案元组。在此过程中用计数器累加即可。\n\n## 错误\n\n思路理解的差不多，但是在写的时候，一些细节方面还是出了问题：\n\n1. 累加时，累加的数值出现问题。\n2. （疑问）hashset的key和value取什么\n\n个人理解如下：\n\n- <u>（疑问）hashset的key和value取什么</u>\n\n  hashset是用来记录前两个数字的和出现情况的。那么key应该是两个数字的和，value应该是这个和出现的频率（次数）。\n\n- <u>累加时，累加的数值出现问题。</u>\n\n  前面说了，hashset记录的是前两个数字的和出现的频率，那么在累加的时候，应该是要加上频率（次数）而非单纯的加一。\n\n## 代码实现\n\n**hashset实现：**\n\n```c#\npublic int FourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4)\n{\n    int ans = 0, temp;\n    Dictionary<int, int> dic = new Dictionary<int, int>();\n\n    //记录前两位相加的结果出现的频率\n    foreach (int num1 in nums1)\n    {\n        foreach (int num2 in nums2)\n        {\n            if(dic.ContainsKey(num1 + num2))\n            {\n                dic[num1 + num2]++;\n            }\n            else\n            {\n                dic.Add(num1 + num2, 1);\n            }\n        }\n    }\n\n    //计算后两位相加的结果，通过这个结果与最终结果的差值查找是否有前两位的和匹配\n    foreach(int num3 in nums3)\n    {\n        foreach(int num4 in nums4)\n        {\n            temp = 0 - num3 - num4;\n\n            if(dic.ContainsKey(temp))\n            {\n                ans+= dic[temp];\n            }\n        }\n    }\n\n    return ans;\n}\n```\n\n# 赎金信\n\n[代码随想录 0383.赎金信](https://programmercarl.com/0383.赎金信.html#思路)\n\n[383. 赎金信 - 力扣（LeetCode）](https://leetcode.cn/problems/ransom-note/description/)\n\n（用时：0.3小时）\n\n## 思路\n\n本题和前面一道四数相加II有点像，只是这道题的变成了两个。\n\nmagazine 中的每个字符只能在 ransomNote 中使用一次，那么就不是查看元素出现的频率，而是单纯查看是否出现即可。\n\n字母一共26个（题目假设只看小写）并不多，故用数组实现哈希表。\n\n## 错误\n\n这道题是比较简单的题，但是在一些细节方面还是出了问题：\n\n1. 看错题，以为是要查看字母出现的频率。\n2. 要先处理magazine再处理ransomNote。\n\n个人理解如下：\n\n- <u>看错题，以为是要查看字母出现的频率。</u>\n\n  这个问题就没什么好说的了。。。查看字母的频率用键值对结构（dictionary）、查看字母是否出现用hashset。数组结构两种都可以用，用数组要看这个表会有多大。\n\n- <u>要先处理magazine再处理ransomNote。</u>\n\n  题目意思是检验ransomNote的字母在magzine的情况（magazine 中的每个字符只能在 ransomNote 中使用一次）。那么magzine要么是包含ransomNote的关系（返回true），要么就是不匹配的关系（返回false）。\n\n  先得得到magzine的元素，再探究ransomNote所有的元素是否在ransomNote出现，且magzine的字母只用一次。\n\n## 代码实现\n\n```c#\n/// <summary>\n/// 哈希数组实现\n/// </summary>\n/// <param name=\"ransomNote\"></param>\n/// <param name=\"magazine\"></param>\n/// <returns></returns>\npublic bool CanConstruct(string ransomNote, string magazine)\n{\n    int[] hash = new int[26];\n\n    for (int i = 0; i < magazine.Length; i++)\n    {\n        hash[magazine[i] - 'a']++;\n    }\n\n    for (int i=0;i<ransomNote.Length;i++)\n    {\n        hash[ransomNote[i] - 'a']--;\n    }\n\n    for (int i=0;i<hash.Length;i++)\n    {\n        if (hash[i]<0)\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\n# 三数之和\n\n[代码随想录 0015.三数之和](https://programmercarl.com/0015.三数之和.html)\n\n[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/description/)\n\n（用时：1小时）\n\n## 思路\n\n和前面的四数相加II不同，本道题是在一个数组中找答案，答案元组不能重复（例如123 和321其实是一个元组）\n\n本题的重点在于去重。\n\n题目是在哈希表章节出现的，去重、唯一性第一反应是用哈希表做。卡哥并没有讲解哈希的方法，因为去重很麻烦\n\n- 哈希的思路应该是先求出前两项a+b的和，再通过答案和哈希表查找第三项c是否存在。\n- 哈希的结构中，hashset是只记录是否存在，不记录存在次数的，那么可能出现，1 2 1，而1只出现过一次，同一个元素被多次使用。此时感觉可以用键值对的类型来记录出现次数？\n- 但是如果要记录次数，就得配合其他的变量使用。比如让某个数字使用了一次值就--，这是循环一轮时的操作，在新一轮的值又得恢复原本的值。。。这里就很麻烦。\n- 此外，用记录出现次数的键值对类型来做也要额外去重（这里就是卡哥说的去去重麻烦），额外对答案列表中重复的元组去重。\n- 去重的方式其实就是来个二重循环，定一个元组，然后对其他的元组进行遍历比较。这里元组中数字的顺序还不一样，意味着if的条件不能单纯的num1[i]==num2[i]这种，还得处理。\n\n卡哥讲授的是双指针的方法。\n\n- 一重循环探索确定第一项数字a。\n- 循环中用left和right分别对数字a后的区域进行收缩判断。\n- 这个方法的数组要是有序的。\n- 这中间加上数字a的去重和剪枝操作。\n\n总结来说：\n\n- 先对数组排序，这里的思路是认为数组升序。\n\n- 排序后，最外层的循环遍历数字a的情况。\n\n  遍历过程中对数字a进行去重，如果此时a的数值已经出现过了，那就向后遍历（因为是有序的，重复的数字会连续出现）。\n\n  还可以对数字a剪枝。题目的和固定为是0，那么如果数字a大于0，那么该数组不可能会有答案元组（因为是升序的，数字a是三个数字中最小的）\n\n- 在确定数字a后，用left和right分别表示数组后续剩下的区域，对这块区域进行收缩。\n\n- 收缩过程中，如果找到了合适的值就可保留下来。\n\n  若nums[i] + nums[left] + nums[right] == 0，表示这组答案是可以的，记录下来即可，然后两个指针一起收缩。\n  若<0，表示目前的有值有点小，那么让left++即可（数组升序）\n  若>0，表示目前的有值有点大，那么让right--即可（同理）\n\n- 收缩过程中，要对left和right对应的值进行去重。\n\n  相同的数值是连续出现的，让left和right指向的值和相邻值不同，即可达到去重的目的。\n\n  需要注意的是，去重是在该答案已经有了的情况下才需要对left和right接下来的值进行去重。这说明left和right的去重是要在答案元组被记录下来后的（卡哥提到的“先记录下来再去重”）\n\n## 疑问点\n\n看完视频和讲解，对解法还是有一些质疑：\n\n1. 疑问1：为什么找到答案时，双指针同时收缩？\n2. 疑问2：right和left的去重逻辑和双指针收缩顺序的问题？\n3. 疑问3（错误）：数字a的剪枝\n\n个人理解如下：\n\n- <u>为什么找到答案时，双指针同时收缩？</u>\n\n  找到答案后，i、left和right的值都是固定的。如果只是收缩left或right，加法式子中其中两个加数不变，那么另一个加数的值也应该是固定的，那么此时这组答案应该有了就重复了。\n\n- <u>right和left的去重逻辑和双指针收缩顺序的问题？</u>\n\n  这里个人认为放在前后都行。\n\n  卡哥是先去重，再收缩。收缩比较的是left和left+1（right和right-1）。我个人是right和left的去重逻辑放在双指针收缩前，收缩比较的是left和left-1（right和right+1）。这里顺序与收缩逻辑对应一下就可以了。\n\n- <u>数字a的剪枝</u>\n\n  这里在写程序时也出现了错误（但是因为是前一天做的，现在忘了这里是怎么错的。。。放上来当作巩固吧）。结果要求是0，数组是升序，那么如果第一个数都大于了0，此数组中想要三个数相加为0是无解的。\n\n## 代码实现\n\n**双指针法：**\n\n```c#\n/// <summary>\n/// 双指针法\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <returns></returns>\npublic IList<IList<int>> ThreeSumFun1(int[] nums)\n{\n    IList<IList<int>> ans = new List<IList<int>>();\n    int left, right;\n\n    Array.Sort(nums);\n\n    for (int i = 0; i < nums.Length; i++)\n    {\n        if (nums[i] > 0) return ans;\n\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\n\n        left = i + 1;\n        right = nums.Length - 1;\n\n        while (left < right)\n        {\n            if (nums[i] + nums[left] + nums[right] == 0)\n            {\n                ans.Add(new List<int> { nums[i], nums[left], nums[right] });\n                left++;\n                right--;\n\n                while (left < right && nums[left] == nums[left - 1]) left++;\n                while (left < right && nums[right] == nums[right + 1]) right--;\n            }\n            else if (nums[i] + nums[left] + nums[right] < 0)\n            {\n                left++;\n            }\n            else\n            {\n                right--;\n            }\n        }\n\n    }\n    return ans;\n}\n```\n\n# 四数之和\n\n[代码随想录 0018.四数之和](https://programmercarl.com/0018.四数之和.html#算法公开课)\n\n[18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/description/)\n\n（用时：2小时）\n\n## 思路\n\n这道题的思路是在前一道三数之和的基础上的。\n\n三数之和中，哈希法太过复杂，因此卡哥优先讲解的是双指针法，这道题依旧使用的是双指针法。由于多了一个数，因此循环需要多加一层。\n\n本道题就是先确定前两个数字ab，然后依旧用left和right收缩。\n\n## 错误\n\n写的时候错了一些：\n\n1. 错误1：b剪枝操作的返回值出了问题\n\n个人理解如下：\n\n- <u>b剪枝操作的返回值出了问题</u>\n\n  在三数之和时，只有一层循环因此在剪枝时，直接让整个函数返回列表也是可以的。这个想法延续要了四数之和，四数之和的第一层循环是和三数一样，因此没有出问题，但是第二层循环不能这么写。\n\n  以力扣报错的 -3, -2, -1, 0, 0, 1, 2, 3 这组数据为例。一共是8组答案，程序只判断出了7组，落了一组。经过调试，发现是在-2 0 0 2 这组答案出现后，后面一组的答案没有出现，下图是出现问题前记录的一组答案：\n  <img src=\"https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/10/20240510121130.png\" alt=\"image-20240510121123236\" style=\"zoom:50%;\" />\n  接着往后继续调试，在某一步中，发现第二层循环对b的剪枝操作让函数直接跳出了。<img src=\"https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/10/20240510121256.png\" alt=\"image-20240510121256764\" style=\"zoom:33%;\" />\n  查看后发现，i和j下标对应的数组值相加后恰好大于target且他们也大于0。但是后续的-1 0 0 1也是一组答案，这里由于b剪枝的原因直接跳过了。这里就是问题所在。\n  <img src=\"https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/10/20240510121339.png\" alt=\"image-20240510121339577\" style=\"zoom:50%;\" />\n\n## 代码实现\n\n**双指针法：**\n\n```c#\n/// <summary>\n/// 双指针法\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <param name=\"target\"></param>\n/// <returns></returns>\npublic IList<IList<int>> FourSumFun(int[] nums, int target)\n{\n    IList<IList<int>> ans = new List<IList<int>>();\n    int left, right;\n\n    Array.Sort(nums);\n    for (int i=0;i<nums.Length;i++)\n    {\n        //a剪枝操作\n        if (nums[i] > 0 && nums[i] > target) break;\n\n        //a去重操作\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\n\n        for (int j=i+1;j<nums.Length;j++)\n        {\n            //b剪枝操作\n            if (nums[i] + nums[j] > 0 && nums[i] + nums[j] > target) break;\n\n            //b去重操作\n            if (j > i + 1 && nums[j] == nums[j - 1]) continue;\n\n            left = j + 1;\n            right = nums.Length-1;\n\n            while(left<right)\n            {\n                if (nums[i] + nums[j] + nums[left] + nums[right] == target)\n                {\n                    ans.Add(new List<int>() { nums[i], nums[j], nums[left], nums[right] });\n\n                    left++;\n                    right--;\n\n                    //去重\n                    while (left < right && nums[left] == nums[left - 1]) left++;\n\n                    //去重\n                    while (left < right && nums[right] == nums[right + 1]) right--;\n                }\n                else if (nums[i] + nums[j] + nums[left] + nums[right] < target)\n                {\n                    left++;\n                }\n                else\n                {\n                    right--;\n                }\n            }\n        }\n    }\n\n\n    return ans;\n}\n```\n\n# 后记\n\n前三道题是在昨天（5.9）写的，没来得及文字记录。最后一道题和文字记录都是今天（5.10）写的。\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习"],"categories":["computerStudy"]},{"title":"GAME101-Lecture06学习","url":"/2024/05/08/GAME101-Lecture06学习/","content":"\n# 前言\n\n上节课主要讲的是三角形的光栅化。重要的思想是要利用像素的中心对三角形可见性的函数进行采样。\n\n这节课主要就是反走样。\n\n# 反走样引入\n\n![image-20240508211643655](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508211650.png)\n\n通过采样，得到的这个三角形和实际的三角形有很大的区别。这种效果叫做锯齿，学名叫走样（aliasing）\n\n## 采样产生的问题\n\nartifacts:表示图形学中一切看上去不太对的东西。\n\n采样会产生一系列问题，其本质都是信号（或者说采样的函数）变得太快了，以至于采样的速度跟不上它变化的速度。\n\n- 锯齿（aliasing）\n- 摩尔纹：将图像的奇数行和奇数列就可以产生\n- 车轮效应：生活中高速行驶的汽车，在视频中看上去的效果可能是倒着转的。人眼在时间中的采样出了问题。\n\n## 防走样的做法\n\n![image-20240508214247976](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508214248.png)\n\n在采样之前做一个模糊（滤波），可以进行反走样。（而先走样在模糊的话，无法达到效果。）\n\n如图在三角形采样前，做一遍模糊，然后再对这些像素点进行采样。\n\n# 傅里叶\n\n## 傅里叶级数展开\n\n![image-20240508214953961](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508214954.png)\n\n任何一个周期函数都可以写成一系列正弦和余弦函数他们的线性组合以及他们的常数项，这就叫做傅里叶级数展开。\n\n## 傅里叶变换\n\n傅里叶变换和傅里叶级数展开并不是一个东西。\n\n![image-20240508215229531](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508215229.png)\n\n给定任意一个函数f(x)，经过一系列操作变成另外一个函数F(x)，这个变换过程叫做傅里叶变换。\n\nF(x)通过逆变换也可以变回f(x)，叫做逆傅里叶变换。\n\n# 走样探究\n\n## 频率\n\n![image-20240508214705389](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508214705.png)\n\n定义f为频率。\n\n用f即可定义波变化有多快，从而也能定义周期T。\n\n\n\n### 傅里叶变换的应用\n\n**傅里叶变换可以把一个函数（图形学中将一幅图像看作一个二维函数），从时域（空间和时间都称为时域）变为频域。**\n\n![image-20240508220729848](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508220730.png)\n\n我们对左边的图进行一次傅里叶变换，从时域变为频域，就会得到右边的图。\n\n将右边图的中心定义为低频的区域，那么从中心到四周频率会越来越高。不同频率表示的信息多少，我们通过亮度来表示。\n\n右图中，图像的中心是最亮的，而前面我们定义了中心是低频，这就意味着左边的图像中，信息都集中在低频区域。\n\n右图中有一个十字的线。这是做傅里叶变换时会出现的现象。因为在分析一个信号时，会认为它是周期性重复的信号，但是大多数图都是不周期性重复的信号。\n\n- 可以将左图当作是一个周期，那么这个图的周期性重复就是类似桌面平铺的样子。左图在左右上下边界后就没有画像了，分析的时候看作将这张图左右上下叠了无数个，这就是无数个周期。\n- 此时有了一个问题，大多数图的左右边界是不一样的（即图左右的边缘不一样）。当我们让这幅图和左边重复的图衔接时，衔接处的像素会产生一个剧烈的变化（可以想象成右边界是黑的，但是用来衔接的旁边的左边界是白的，黑到白直接是一个突变），就会产生一个极高的高频。\n\n**傅里叶变换能够让我们看到，左边的图像在不同频率长什么样子（即信号在不同频率长什么样，叫做频谱）。**\n\n### 频率中的采样\n\n**傅里叶变换就是把函数变成不同的频率的段，然后把不同频率的段显示出来。**\n\n![image-20240508215406543](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508215406.png)\n\n- 更高的频率需要更快的采样\n- 低频信号:充分采样以进行合理的重构\n- 高频信号采样不足:重建错误地似乎是从一个低频信号\n\n如图，绿色曲线表示频率，黑色点表示采样点，蓝色虚线是通过采样点还原的频率。\n\n，如果我们用同样的采样方法来对不同的波进行采样，采样的效果是不一样的。因此，我们需要让函数变化的频率和采样的频率匹配，才能让所有的采样都达到一个想要的效果。\n\n### 频率中的走样\n\n![image-20240508220013124](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508220013.png)\n\n- 高频信号采样不足：采样错误地表现为来自低频信号\n- 在给定的采样率下难以区分的两个频率称为“aliases”（走样）\n\n如图，首先让蓝色的函数根据图中白色点的方式进行采样。根据采样的点还原，可以得到黑色的这个函数。\n\n接着假设黑色线是待采样的函数，如果也用白色点的方式进行采样。还原后得到的依旧是这个黑色的这个函数。\n\n**同样的一个采样方法，采用两种不同的频率的函数得到的结果，我们无法区分它们，这就叫做走样**\n\n## 滤波\n\n滤波（filtering）：把某个特定频段（就是一个规定的范围内的频率）给删除，这个对应的信号是如何变化的，叫做滤波（即去掉一系列频率）\n\n### 高通滤波\n\n将低频信号全部抹去，只剩下高频的信号的滤波叫高通滤波。\n\n![image-20240508223154054](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508223154.png)\n\n在傅里叶变换的基础上，将低频信号全部抹去，只剩下高频的信号，就是右图。将剩余的高频信号逆处理回去，就是左图。\n\n可以发现，**高频的东西其实就是表示图像内容的边界**（比如图中的袖口等）。\n\n边界可以理解成是突变比较大的“分水岭”，这个边界左右（或上下）发生了非常剧烈的变化，而图像信息变化快的地方频率就高。\n\n进一步可以认为，高频的地方图片信息变化非常大。\n\n### 低通滤波\n\n将所有高频信息抹掉，只剩下低频信息的滤波叫低通滤波。\n\n![image-20240508224502926](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508224503.png)\n\n在傅里叶变换的基础上，将所有高频信息抹掉，只剩下低频信息，可以发现所有的“边界”都去掉了，整个图像是一个模糊的样子。\n\n### 特定频段滤波\n\n![image-20240508224613677](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508224613.png)\n\n将高频和低频的信息都去掉，留下某一段特定频率的信息，此时提取到的是一些不那么明显的“边界”特征。\n\n![image-20240508224809092](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508224809.png)\n\n同样，如果左侧留下的光圈更加外边（更接近高频），那么这个“边界”特征会越明显。\n\n### 卷积、平均\n\n平均（averag）操作：可以想象成低通滤波，造成模糊的效果。\n\n#### 卷积操作\n\n![image-20240508225213647](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508225213.png)\n\n![image-20240508225457436](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508225457.png)\n\n假设滤波器（filter）是一个窗口，窗口中有若干个各自。将信号与滤波窗口进行点乘操作（第三行的式子），点乘的结果写回窗口的中心值。\n\n其实就是将某个原始的信号取其周围的信号进行加权求和，得到一个新的信号。任意一个数都是周围若干数的平均。\n\n**将某一种滤波作用在一个信号上，进行<u>卷积操作</u>（点乘加权平均），得到一个新的信号。**（<u>这是图形学简化后的定义，不是数学上的定义</u>）\n\n（这就是卷积能够提取特征的原因）\n\n#### 卷积定理\n\n![image-20240508232754543](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508232831.png)\n\n对一个图像进行卷积操作，得到新的图像。对应的就是将原本图像对应的信号，乘以一个信号，就会得到一个新的信号，被乘数的那个信号就是卷积，新的信号就是新的图像。\n\n**时域的卷积 = 频域的乘积，反之亦然**\n\n#### 卷积盒\n\n![image-20240510145425636](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/10/20240510153305.png)\n\n卷积盒可以看作是一个滤波器，**卷积操作就是一个低通滤波器**，让图像更加模糊。\n\n写成图中数字加盒子的形式，相当于是一个归一化的操作。\n\n![image-20240510150252559](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/10/20240510153305-1.png)\n\n卷积盒的范围变大，对应的频率是变小的，结果更加模糊。\n\n原因个人是这么理解的：\n\n- 假设在这个box变得超级大，大到以任意一个像素为中心，都能覆盖得了所有得像素。\n- 看前面的卷积操作的计算方式，其实就是以每一个像素为中心，box覆盖到的像素一起取平均。每个像素取平均的值，在box超级大时，就可以认为是同一批数据。\n- 那么卷积操作后，无限大的box导致每个像素长得一摸一样。这就是模糊到了一个程度，整张图看不出任何信息。相当于边界全部没有了。**卷积盒box越大，边界越少，图像信息越来越少，图像越来越模糊。**\n- 在频域中，如上图box变大后，频域图中间的亮点们变小变淡了。前面我们将亮度高的当作高频，这里就相当于高频越来越少。**卷积盒box越大，高频信息越来越少。**\n\n\n\n## 频域中的采样\n\n![image-20240510153725359](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/10/20240510153725.png)\n\n左图是在时域中的三个函数。我们用函数c（冲激函数）乘以函数a，就可以得到函数a上离散的点（函数e）。函数e就是采样结果。\n\n右图是各个函数对应在频域上的函数。时域上函数相乘变成一系列的点，对于到频域上，就是把原始的函数的频谱复制粘贴。（时域的乘积等于频域上的卷积。）\n\n**在频域中，采样就是在重复频率或者频率上的内容。**\n\n\n\n## 频域中的走样\n\n![image-20240510154055787](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/10/20240510154055.png)\n\n**采样在频域中就是将频谱复制粘贴。**\n\n正常情况下，依次的复制粘贴如图中第一个函数的样子。但是如果采样的过快，一段没有复制粘贴完，另一段就又要复制粘贴上来，就会导致频谱之间的间隔越小，信号混在了一起，就是走样。\n\n这里时域和频率的解释是相反的关系，**采样的越稀疏（采样的频率越小），对应频谱上就越密集（时域上的信号就会叠在一起），这种情况下就是走样。**\n\n\n\n# 防止走样的措施\n\n![image-20240510154629224](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/10/20240510154629.png)\n\n- 如何减少混叠误差（走样）?\n- 方案1:提高采样率本质上增加了傅立叶域中样本之间的距离\n- 比如：更高分辨率的显示器、传感器、帧缓冲器..\n- 但是:成本高&可能需要非常高的分辨率\n- 选项2:抗锯齿（防走样）\n- 在重复之前使傅里叶的内容“变窄”\n- 比如：在采样前滤除高频\n\n# 反走样探究\n\n## 原理\n\n![image-20240510154956339](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/10/20240510154956.png)\n\n先做一个模糊，去掉高频，让频谱覆盖的面小一些，这样就能防止频谱重叠。\n\n## 模糊方法\n\n严格意义上来说，MSAA这些抗锯齿技术都是对反走样的近似，不能完全解决放走样。\n\n### MSAA\n\n![image-20240510160327658](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/10/20240510160327.png)\n\n- 通过对一个像素内的多个位置进行采样并取其值的平均值，来近似模拟1像素箱形滤波器的效果。\n\n#### 例子展示\n\n![image-20240510160909144](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/10/20240510160909.png)\n\n假设有一个三角形覆盖了一些像素。\n\n1. ![image-20240510160945511](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/10/20240510160945.png)\n   在每个像素中取NxN样本。\n\n   假如像素内部多一些采样点，比如用2*2的点\n\n2. ![image-20240510161049424](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/10/20240510161049.png)\n\n   在像素内部取采样点后，查看采样点在三角形内外的情况。\n\n   为方便显示，我们可以让像素内部的采样点在三角形内的越多，颜色越深。\n\n3. ![image-20240510161422802](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/10/20240510161422.png)\n\n   最终的结果，我们将得到每个实际像素在三角形中的覆盖率。\n\nMSAA是对反走样的第一步模糊进行操作，而下一步的采样操作是隐含在这个过程中的。\n\n#### 注意\n\nMSAA不是通过提高分辨率直接解决走样问题。（**增加采样点是近似合理的覆盖率**，并没有真的提高分辨率）\n\n在实际运用时，对像素处理的方法并不是像例子取像素中心然后规则的矩形的增加采样点。实际中人们会用其他更加有效的图案，并且有些点会被临近的像素复用。\n\n### FXAA\n\nFXAA (Fast Approximate AA)快速近似抗锯齿\n\n图像的后期处理，先得出一张图。通过图像匹配的方式找到图中的锯齿，然后把他换成模糊。（但是注意前面有说过，不能先得到一张有锯齿的图再做模糊）\n\n这个技术中没有涉及到采样，是在图像层面上做的抗锯齿。\n\n### TAA\n\nTAA (Temporal AA)\n\n假如场景是静止的，相邻两帧显示的一样，但是相邻两帧一个像素内部不同位置上的点来感知是否在三角形内。\n\n在时间范围内得到的静态的场景图的边界会各不相同。**TAA复用上一帧的感知结果，相当于将MSAA的样本分布在时间上。**\n\n如果是动态的，就是光线追踪（TAA和光线追踪用的是同一个思想）\n\n# 超分辨率\n\n一张图将其大小变大（比如512\\*512变成1024\\*1024），单纯的拉大会看上去图全都是锯齿。如果不想看到锯齿，就需要一个超分辨率的过程。\n\n本质上是高分辨率的图采样率不够。\n\n## DLSS\n\n通过深度学习的方法实现超分辨率的过程（就是猜）\n\n# 总结\n\n前提：图形学中将一幅图像看成一个二维函数。\n\n## 频率、频谱\n\n**频率**用来表示波变化的快慢。\n\n一个函数（图像）经过傅里叶变换后，能够得到其频谱。\n\n- 函数f通过变换能够变成另一个函数F，f通过逆变换也能够变回F。变换过程就叫做傅里叶变换或逆傅里叶变换。\n- **频谱**是图像（信号）在不同频率的样子，是频率的分布曲线。\n- 在频谱中，每间隔一段就取一个数据点，这个取点的过程叫做**采样**。\n- 同样的一个采样方法，采用两种不同的频率的函数得到的结果，我们无法区分它们，这叫做**走样**\n\n## 滤波\n\n将某一范围内的特定频率去掉的过程称为**滤波**。\n\n个人理解滤波其实就是一个函数，将图像（信号、函数）与这个滤波函数叠加，就能实现实现滤波的效果。\n\n**高通滤波**就是能够去掉低频频段的函数（信号）。图像增加高频滤波后，图像边界将变得明显。\n\n同理，**低通滤波**就是去掉高频频段的函数（信号）。\n\n除此之外还有一些特定频段的滤波。图像增加低频滤波后，图像将变得模糊。\n\n## 卷积\n\n**卷积**在图形学中就是加权求平均。\n\n**卷积操作就是一个低通滤波器**。\n\n- 将某一种滤波作用在一个信号上，进行<u>**卷积操作**</u>（点乘加权平均），得到一个新的信号。\n- <u>这是图形学简化后的定义，不是数学上的定义</u>\n\n卷积定理主要是证明了**时域的卷积 = 频域的乘积，反之亦然。**\n\n- 从例子上看，就是一个图像进行卷积操作后得到新的图像，在频域中就是一个频谱乘以卷积操作的频域得到一个新的频谱。\n\n**卷积盒可以看作是一个滤波器**。\n\n- 卷积盒box越大，边界越少，图像信息越来越少，图像越来越模糊。\n\n## 频域中的定义\n\n**采样在频域中就是将频谱复制粘贴。**\n\n- 时域上函数相乘变成一系列的点。\n- 对应到频域上，就是把原始的函数的频谱复制粘贴。\n\n**复制粘贴的频谱之间的间隔越小，频谱重叠在了一起（信号混在了一起）就是走样。**\n\n采样的越稀疏，采样的频率越小，对应频谱上就越密集（时域上的信号就会叠在一起）。\n\n## 反走样\n\n在采样之前做一个模糊（滤波）可以达到反走样的效果。\n\n- 需要模糊的话需要做低通滤波。去掉高频，在频域的体现就是频谱覆盖的面会小，防止频谱重叠。\n\nMSAA、FXAA和TAA都是做模糊一些技术。\n\n- MSAA是增加像素的采样点，近似合理的覆盖率，从而达到模糊的效果。\n- FXAA则是先采样，形成图像后，再利用图像匹配找到锯齿的部分，模糊处理后替换锯齿部分（但是会违背采样之前做一个模糊的理论，这样达不到很好的效果，优点是很快）\n- TAA则是会复用上一帧的感知结果，相当于将MSAA的样本分布在时间上。\n\n# 后记\n\n这节课的知识真的多且难，分了两天看才看完。。。\n\n感觉开始慢慢接触专业的知识了，闫老师的课确实很厉害，讲的真的很好。\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"csharp数据结构：HashSet","url":"/2024/05/08/csharp数据结构：HashSet/","content":"\n学习链接：[C#数据结构 HashSet 用法 - yinghualeihenmei - 博客园 (cnblogs.com)](https://www.cnblogs.com/Dongmy/p/18170781)\n\n# 命名空间\n\n```c#\nSystem.Collections.Generic\n```\n\n# 特点\n\n无序性、**唯一性**、高性能、不支持索引、线程不安全\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["CSharp 数据结构"],"categories":["computerStudy"]},{"title":"算法练习day6","url":"/2024/05/08/算法练习day6/","content":"\n# 哈希表理论基础\n\n哈希表在放弃算法后，就再也没有接触过这个了。\n\nc++标准库提供的数据结构中，有数组、set和map三种可以用于实现哈希表。\n\n- 数组不用提\n- set：中文是集合的意思\n\nc#的数据结构中，也有hashtable、hashSet和dictionary可以用。\n\n# 有效的字母异位词\n\n[代码随想录 0242.有效的字母异位词](https://programmercarl.com/0242.有效的字母异位词.html)\n\n[242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/description/)\n\n（用时：0.5小时）\n\n## 思路\n\n这道题直接用双重循环直接搜索也是可以的，这个思路比较粗暴就不多说。\n\n题目需要我们比较两个字符串的字母是否互为异位。我们可以查看两个字符串的字母是否完全一样，需要看的是字母的出现频率是否一样。\n\n一般的思路就是先将第一个字符串中元素出现的频率情况记录下来，接着与第二个字符串进行对照。记录的容器有很多种，第一反应想到的是数组。用数组下标区别不同元素，记录出现的频率即可。\n\n这里用数组下标区别元素，对应统计频率的想法就是哈希的思想，<u>这里哈希的实现结构就是数组。</u>（字母只有26个，故可以用数组。）\n\n总结来说：\n\n- 首先需要用一个循环将第一个字符串元素的出现情况更新在哈希数组上\n- 接着在用一个循环将第二个字符串元素的出现情况更新在同一哈希数组上（或者可以用两个哈希数组，然后比较不同也行）\n- 最后再用一个循环，判断两个字符串元素的出现情况是否一样（如果是两个哈希数组就直接比较即可，如果是一个哈希数组，那就通过哈希值来判断。）\n\n## 错误\n\n写的过程中也有遇到一些错误：\n\n1. 后面两个循环合并在一起写了（即将第二个字符串元素的出现情况的更新与判断两个字符串元素的出现情况放在了一起同时进行）\n2. 第三个循环中的if判断条件出错（写成了hash[i]<0）（即判断两个字符串元素的出现情况是否一样的条件写错了。\n\n个人理解如下：\n\n- <u>后面两个循环合并在一起写了</u>\n\n  不能把后面两个循环合在一起写。第二个循环的目的是记录字符串t字母的出现情况，第三个循环的目的是查看所有字母的情况。第二个循环中是不会遍历到所有字母的。\n\n- <u>第三个循环中的if判断条件出错（写成了hash[i]<0）</u>\n\n  借用官方提供的测试数据：s=\"ab\" t=\"a\"。在最后一个循环中，a对应的数组值是0，但b是1。只有当哈希数组中所有的值都等于0，才表示两个字符串元素的出现情况完全相同。这里应该用hash[i]!=0判断才行。\n\n## 代码实现\n\n```c#\n/// <summary>\n/// 哈希数组遍历\n/// </summary>\n/// <param name=\"s\"></param>\n/// <param name=\"t\"></param>\n/// <returns></returns>\npublic bool IsAnagram(string s, string t)\n{\n    int[] hash = new int[26];\n\n    for (int i=0;i<s.Length;i++)\n    {\n        hash[s[i] - 'a']++;\n    }\n\n    for (int i=0;i<t.Length;i++)\n    {\n        hash[t[i] - 'a']--;\n    }\n\n    for (int i=0;i<hash.Length;i++)\n    {\n        if (hash[i]!=0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n# 两个数组的交集\n\n[代码随想录 两个数组的交集](https://programmercarl.com/0349.两个数组的交集.html)\n\n[349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/description/)\n\n（用时：1小时）\n\n## 思路\n\n本道题要找两个数组的交集。根据力扣上的示例，可以认为找交集是要找两个数组重复的元素。判断一个元素是否重复，就是查看在这两个数组中，该元素是否都出现了。\n\n简单的暴力枚举就是两层循环直接搜索。\n\n这里卡哥提供的是用哈希的思路。力扣的题目上两个数组的数值都小于1000，故可以用数组实现哈希表。卡哥也有解释这是力扣后面修改的条件，当数值大到一定程度时，数组就会很费空间。因此本道题我们考虑用其他的容器来实现。\n\n卡哥教的c++使用的是set集合结构，在c#中可以使用hashSet。\n\n总结来说：\n\n- 首先在第一个数组中统计出现的元素。\n- 接着在第二个数组中判断前面出现的元素是否有出现。在这同时要记录下重复的元素。\n\n## 重点\n\n本道题和上一题有些不一样，上一题的元素是比较两者的出现频率是否一样，这一题的元素是比较两者是否都出现过，并且还需要记录两者都出现的元素本身。\n\n这里需要注意两个重点：\n\n1. <u>元素只要在两者出现过就可以了。</u>\n\n   有一处出现了多次和出现一次是一样的，那么意味着**要给数组的元素去重**。\n\n2. <u>两者都出现的元素要记录下来。</u>\n\n   记录的条件是通过哈希表判断出来的：要么就得在第二步判断元素是否重复出现时一起记录；要么就得先将判断结果记录下来后续再来一个循环构造答案数组。\n\n   如果是前者，边判断边记录。\n\n   - 普通的数组结构，数组的长度是固定的。为了保险将长度提前定义成足够大，那么就需要同时记录数组的有效长度，以便最后在对数组进行处理，去掉额外的数组空间。\n   - 此外c#里面还有list、arrayList等其他数据结构可以使用，这些可以实现动态数组。\n\n   如果是后者，先将判断结果记录下来。\n\n   - 记录的同时需要一起记录有效数组的长度，在后续构建答案数组时使用。\n\n## 代码实现\n\n**哈希数组实现：**\n\n```c#\n/// <summary>\n/// 哈希数组实现\n/// </summary>\n/// <param name=\"nums1\"></param>\n/// <param name=\"nums2\"></param>\n/// <returns></returns>\npublic int[] Intersection(int[] nums1, int[] nums2)\n{\n    int ansLen = 0;\n\n    //构建哈希数组\n    int[] hash = new int[1001];\n    for (int i=0;i<nums1.Length;i++)\n    {\n        //输入构建哈希数组时，nums1去重\n        if (hash[nums1[i]]==0)\n        {\n            hash[nums1[i]]++;\n        }\n    }\n\n    //查找并更新哈希数组\n    for (int i=0;i<nums2.Length;i++)\n    {\n        if (hash[nums2[i]]==1)\n        {\n            //通过哈希数组查找时，num2去重\n            hash[nums2[i]]++;\n            ansLen++;\n        }\n    }\n\n    //通过哈希数组得到数组交集\n    int[] ans = new int[ansLen];\n    ansLen = 0;\n    for (int i=0;i<hash.Length;i++)\n    {\n        if (hash[i] == 2)\n        {\n            ans[ansLen++] = i;\n        }\n    }\n    return ans;\n\n}\n```\n\n**用hashSet实现：**\n\n```c#\n/// <summary>\n/// 用hashset实现\n/// </summary>\n/// <param name=\"nums1\"></param>\n/// <param name=\"nums2\"></param>\n/// <returns></returns>\npublic int[] Intersection2(int[] nums1, int[] nums2)\n{\n    HashSet<int> hashSet = new HashSet<int>();\n    HashSet<int> ans = new HashSet<int>();\n\n    foreach (int num in  nums1)\n    {\n        hashSet.Add(num);\n    }\n\n    foreach (int num in nums2)\n    {\n        if (hashSet.Contains(num))\n        {\n            ans.Add(num);\n        }\n    }\n\n    return ans.ToArray<int>();\n}\n```\n\n本题用的还是HashSet来定义答案数组，用ToArray函数即可转成普通数组。用HashSet主要时因为\n\n- arrayList不支持泛型，是object类型，要频繁装箱拆箱.\n- List支持泛型，不用装箱拆箱效率较高，但是它的数据不具有唯一性。\n- 更多参考可以看这篇文章：[C#中数组、ArrayList和List三者的区别_c# 有沒有java的list-CSDN博客](https://blog.csdn.net/zhang_xinxiu/article/details/8657431)\n\n综合考虑，还是HashSet方便。\n\n# 快乐数\n\n[代码随想录 快乐数](https://programmercarl.com/0202.快乐数.html)\n\n[202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/description/)\n\n（用时：0.5小时）\n\n\n\n## 思路\n\n刚开始看到这道题，第一反应是循环、递归这些东西。\n\n题目要求就是要一直求各个位数的平方和，直到结果为1，或者无限循环下去永远都不会为1。\n\n## 重点\n\n这道题的重点有两个：\n\n1. 各个位数平方和的求法。\n2. 如何判断这个结果永远都不会到1。\n\n个人理解：\n\n- 各个位置上数字平方和的求法很简单，用模运算和除法即可。\n- 关于如何判断这个结果永远都不会到1，这里就出现了错误。\n\n## 错误\n\n1. 思路有误。认为让其始终循环，直到其s<10或小于某个数时就会停止\n2. 找到了1的判断出错。\n\n个人理解如下：\n\n- <u>思路有误。认为让其始终循环，直到其s<10或小于某个数时就会停止。</u>\n\n  事实上，s即使小于10（当前的结果是个位数），依旧能够通过一次平方变为更大的数。就算是找到个位数，一次的平方无法达到更多的位数，但是多几次平方，依可以以变回去。思考的时候忽略了这道题是只要没有出现1，就需要一直平方下去。而只有1一直平方下去始终不变。\n\n  正确思路：正确的想法应该是根据题目要求一直让各个位数的数字平方然后相加。题目提到说会一直无限循环，那么当开始重复循环时，就代表已经是无法找到1了。\n\n- <u>找到了1的判断出错。</u>\n\n  当最原始的数在运算中，某一次所有位数的平方和是1时，就代表该数是开心数。\n\n  s是用于累加平方的平方和结果。当平方和为1时就表示其是开心数，但while此时的主要功能是用于累加平方和，可能会出现最高位是1导致误判的情况，因此平方和为1且当前的数字各位数都已取出（即n=0）才能确定原始数是开心数。\n\n## 代码实现\n\n**hashSet解法：**\n\n```c#\n/// <summary>\n/// hashSet解法\n/// </summary>\n/// <param name=\"n\"></param>\n/// <returns></returns>\npublic bool IsHappy(int n)\n{\n    int s = 0;\n    HashSet<int> hashSet = new HashSet<int>();\n\n    while(true)\n    {\n        s += (n % 10) * (n % 10);\n        n = n / 10;\n\n        if (n == 0)\n        {\n            if (s==1)\n            {\n                return true;\n            }\n\n            if (!hashSet.Add(s))\n            {\n                return false;\n            }\n            n = s;\n            s = 0;\n        }\n    }\n}\n```\n\n# 两数之和\n\n[代码随想录 两数之和](https://programmercarl.com/0001.两数之和.html)\n\n[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/description/)\n\n（用时：0.5小时）\n\n## 思路\n\n这道题其实就是给定和，让我们在数组中查找能够让加法等式成立的元素。\n\n等式的和是确定的，当我们已知加数时，被加数是可以被计算出来的。那么这就意味着，我们可以在数组中从头进行遍历，每确定一个数为加数，就在数组中查看另外的数中是否有被加数。这个思路就是简单的暴力枚举方法。\n\n也可以用数组去记录值的出现情况，每次判断这个值是否有在这个数组中出现时通过“查表”即可，这里就是哈希表的方法。\n\n哈希表的结构有很多。target最大可以到10<sup>9</sup>，用哈希数组就不合适了。并且题目要求是要输出数组下标。\n\n卡哥将c++时用的是map，而c#我是用的是字典dictionary\n\n- 哈希表HashTable对于int,float这些值类型还需要进行装箱等操作，会非常耗时。\n- 字典Dictionary表示键和值的集合，它支持泛型,相对好一点。\n\n总结来说：\n\n- 整体是对数组进行遍历。\n\n- 在遍历时，首先计算出当前元素下的被加数。\n\n- 接着通过字典，查看被加数是否有出现在数组中。\n\n  若出现了，则直接构建答案数组输出即可（题目提到可以假设只会有一个答案、同一元素的答案不会重复出现且可以按任意顺序返回答案）\n\n  若未出现。若是字典中没有该数，值和下标加入字典，若有则不处理（数组可能是3，3，3的情况，元素值相同选一个即可。）\n\n## 重点\n\n1. 注意两个if的顺序（即注意需要查找被加数是否出现和将加数进入字典这两个操作的先后顺序）\n\n个人理解如下：\n\n- <u>注意两个if的顺序</u>\n\n  在循环中，我们遍历数组，通过结果target可以求得在当前数组元素下的被加数，接着我们需要查找被加数是否出现、将加数进入字典。这里有一个顺序的问题，两个if的顺序本质上是先找被加数还是先增加加数进字典？\n\n  如果先增加加数进字典，接着查找被加数是否出现，那么当被加数和加数数值相等时，就被被判定为已出现，那么就是会让数组的同一个元素在答案里重复出现，这不符合题意。\n\n  先查找被加数再将加数加入字典，这样可以避免重复用一个元素的情况。\n\n## 代码实现\n\n**键值对数据结构实现：**\n\n```c#\n/// <summary>\n/// 键值对数据结构实现\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <param name=\"target\"></param>\n/// <returns></returns>\npublic int[] TwoSum(int[] nums, int target)\n{\n    int[] ans = new int[2];\n    int tempNum;\n    Dictionary<int, int> numberDic = new Dictionary<int, int>();\n\n    for (int i=0;i<nums.Length;i++)\n    {\n        tempNum = target - nums[i];\n\n        if (numberDic.ContainsKey(tempNum))\n        {\n            ans[0] = numberDic[tempNum];\n            ans[1] = i;\n            break;\n        }\n\n        if (!numberDic.ContainsKey(nums[i]))\n        {\n            numberDic.Add(nums[i], i);\n        }\n    }\n    return ans;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习"],"categories":["computerStudy"]},{"title":"算法练习day4","url":"/2024/05/07/算法练习day4/","content":"\n# 前言\n\n中间个人原因断了很久，现在回来继续。。。。\n\n# 两两交换链表中的节点\n\n[代码随想录 两两交换链表中的节点](https://programmercarl.com/0024. 两两交换链表中的节点.htm)\n\n[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)\n\n（用时：0.3小时）\n\n## 思路\n\n这道题的思路其实很简单，两两节点交换，注意在交换前提前保存好可能会断链的节点即可。\n\n同时也需要注意节点交换的顺序问题，其他的就没什么。\n\n至于递归实现，后续有时间再说吧。。。\n\n## 代码实现\n\n```c#\n/// <summary>\n/// 三指针交换\n/// </summary>\n/// <param name=\"head\"></param>\n/// <returns></returns>\npublic ListNode SwapPairs(ListNode head)\n{\n    ListNode visHeadNode, tempNode, curNode;\n    visHeadNode = new ListNode();\n    visHeadNode.next = head;\n    curNode = visHeadNode;\n\n    while(curNode.next!=null && curNode.next.next!=null)\n    {\n        tempNode = curNode.next.next;\n\n        curNode.next.next = tempNode.next;\n        tempNode.next = curNode.next;\n        curNode.next = tempNode;\n\n        curNode = tempNode.next;                \n    }\n\n    return visHeadNode.next;\n}\n```\n\n# 删除链表的倒数第N个节点\n\n[代码随想录 删除链表的倒数第N个节点](https://programmercarl.com/0019. 删除链表的倒数第N个节点.htm)\n\n[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)\n\n（用时：0.5小时）\n\n## 思路\n\n这道题用快慢指针法，即只遍历一次就找到倒数第n个节点。（假设链表长度为N，那么就是找到正数第N-n个节点）\n\n- 快指针与慢指针始终相差N-n+1个节点。\n- 快指针向前探索，直到到达链表结尾（结尾节点的next为null）\n- 慢指针先和快指针拉开N-n+1个节点的距离，随后跟随着快指针的脚步向后遍历即可。\n- 两个指针相差N-n+1，是因为在去除倒数第n个节点（正数第N-n个节点）时，需要通过其前驱节点，因此需要少前进一步。\n- 即**<u>需要找到并让fastNode指向第N-n+1个节点，也可以说fastNode需要先走n+1步</u>**\n\n## 易错/错误点\n\n本题思路其实不难，但在临界值方面和容易出错，因此需要格外注意。自己也是在这里踩坑了。。。\n\n易错或者说比较重要的点有几个：\n\n1. 赋初始值时，fastNode和slowNode的初始值究竟是什么好呢？\n2. 第一个while的判断条件中，n的条件是n>=0还是n>0呢？\n3. 第二个while的判断条件\n\n个人的理解如下：\n\n- n的判断条件\n\n  fastNode需要在第一个while中与slowNode拉开n个节点的距离。\n  对于n的判断条件，n每循环一次就-1。当n=0时，fastNode走了n步，fastNode需要先走n+1步，因此while需要再循环一次，n=0成立。\n\n- fastNode的初始值\n\n  fastNode要么是visHeadNode，要么是visHeadNode.next。visHeadNode.next就是链表真实头节点。\n\n  ​\t\t此时我们需要明白一个问题，先做个假设，假设链表有3个节点，让slow和fast分别在链表的头和尾处：\n  ![微信图片_20240507211111](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/07/20240507211231.jpg)\n\n  ​\t\t可以发现，链表长度为3，而slow和fast之间相隔1个节点。这说明链表的头和尾之间是相隔n-2个节点。\n\n  ​\t\t回到fastNode的初始值问题，假设题目的链表就是如上图所示，如果需要删除的是倒数第3个节点（即真实头节点）：\n  ​\t\t当fastNode=visHeadNode.next（即fastNode=真实头节点）。当n自减到1时，fastNode已经指向了末尾。此时固然可以让第一个while里多一个fast.next!=null的判断条件，第一二个while均可正确通过。但是需要注意最后的移除节点步骤，slowNode是需要移除节点的前驱节点，按照这个逻辑，我们将把第一个节点删除，它是链表的倒数第2个，这与我们的目标不符，这里就出了问题。\n  ​\t\t因此，我们需要让fastNode的初始值为visHeadNode。\n\n- slowNode的初始值\n\n  slowNode在第二个while循环中才需要让其开始遍历，在此之前是没有更改的。slowNode的初始值需要和fastNode一样，因为都是从“头”开始遍历嘛。\n\n- 第二个while中的判断条件\n\n  第二个while的逻辑是让slow和fast向前遍历，直到fastNode找到链表尾节点。链表尾节点的条件是fastNode.next!=null，因此这就是判断条件。\n\n## 代码实现\n\n**快慢指针法：**\n\n```c#\n/// <summary>\n/// 快慢指针法\n/// </summary>\n/// <param name=\"head\"></param>\n/// <param name=\"n\"></param>\n/// <returns></returns>\npublic ListNode RemoveNthFromEnd(ListNode head, int n)\n{\n    ListNode visHeadNode, fastNode, slowNode;\n    visHeadNode = new ListNode();\n    visHeadNode.next = head;\n    fastNode = visHeadNode;\n    slowNode = visHeadNode;\n\n    while (n > 0)\n    {\n        fastNode = fastNode.next;\n        n--;\n    }\n\n\n    while(fastNode.next!=null)\n    {\n        slowNode = slowNode.next;\n        fastNode = fastNode.next;\n    }\n\n    slowNode.next = slowNode.next.next;\n    return visHeadNode.next;\n}\n```\n\n# 链表相交\n\n[代码随想录 面试题 20.07链表相交](https://programmercarl.com/面试题02.07.链表相交.html)\n\n[面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)\n\n（用时：3小时）\n\n## 思路\n\n本道题刚开始只想到双重循环的暴力搜索方法，后来看了卡哥的视频后，原来还可以通过链表长度来实现。\n\n此外，在网站上看C#题解样例时，看到了另外一个很有意思的解法。自己画图后发现，这位大佬用的是环形链表的方法。\n\n### 链表长度同步移动法\n\n两链表若有相交，那么从相交的节点开始往后应均为一样。\n\n假设较短的链表从头节点开始便以相交，那么**较短链表长度即为相交链表可能的最大长度**，这样能一定程度上降低时间复杂度。\n\n总结来说，首先需要得到较短链表的长度，接着让较长链表的指针从与较短链表长度一样的节点开始，最后让两个链表的指针同时向后探索扫描，当指向同一个节点时便找到了相交链表的头节点。\n\n#### 错误\n\n看是看懂了，但是在写的时候还是犯了一些错误：\n\n1. 指针遍历写错了（这个错误只能说是大晚上脑子不清醒吧。。。自己都无语了。。）\n2. 求得短的链表长度后，只动长链表的指针即可。\n\n反思后的理解如下：\n\n- <u>求得短的链表长度后，只动长链表的指针即可。</u>\n\n  这里刚开始让两个指针都在动，导致了短链表的指针到了末尾甚至空值引用了。。。\n  两个链表的可能的相交节点位置是不固定的。求得短的链表长度后，让长的链表的指针指向开头即可，短链表的指针无需动。\n\n### 合并链表追逐法\n\n这个追逐法其实就是将两个链表首尾连在一起，如果有环，说明他们有相交。\n\n此时这个问题就从是否相交转化成了，这一大条链表，首尾相接后，是否还有更小的环。\n\n接着用环形链表的特性：两个指针在环形链表中始终向前跑，若环形链表有环，那么两个指针一定会相遇。（后面一题的环形链表中，卡哥有讲原理）\n\n本道题中，两个指针没有快慢之分，那么他们一定会在两个链表开始相交的节点上相遇。\n\n![image-20240508112919035](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/05/08/20240508112926.png)\n\n#### 重点\n\n此时有个很重要的问题，**如果链表没有相交，那怎么判断他们没有相交？**（即怎么让循环停下来）\n\n两个链表根据他们的长度分为长度相等和长度不等的情况\n\n- 长度相等：当他们共同到尾节点，他们或者他们的next均会等于null，此时就是终止条件。\n- 长度不相等：两个指针走过的节点一个长一个短，那么让走的长一点的指针走一遍短的路、让走的短一点的指针走一遍长的路，\n\n他们会同时走到对方链表的尾节点，他们或者他们的**next均会等于null**，此时就是终止条件。\n\n## 代码实现\n\n**链表长度同步移动法：**\n\n```c#\n/// <summary>\n/// 链表长度同步移动法\n/// </summary>\n/// <param name=\"headA\"></param>\n/// <param name=\"headB\"></param>\n/// <returns></returns>\npublic ListNode GetIntersectionNode(ListNode headA, ListNode headB)\n{\n    ListNode curA = headA,curB = headB;\n    int lenA = 0, lenB = 0;\n\n    //得到较短链表的长度\n    while (curA!=null)\n    {\n        lenA++;\n        curA = curA.next;\n    }\n    \n    while(curB!=null)\n    {\n        lenB++;\n        curB = curB.next;\n    }\n\n    //设置较长链表的指针初始值\n    curA = lenA > lenB ? headA : headB;\n    curB = lenA > lenB ? headB : headA;\n    for (int i=0;i<Math.Abs(lenA-lenB);i++)\n    {\n        curA = curA.next;\n    }\n\n    //两个链表的指针同时向后探索扫描\n    while (curA!=null)\n    {\n        if (curA==curB)\n        {\n            return curA;\n        }\n        curA = curA.next;\n        curB = curB.next;\n    }\n    return null;\n}\n```\n\n\n\n**合并链表追逐法：**\n\n```c#\n/// <summary>\n/// 合并链表追逐法\n/// </summary>\n/// <param name=\"headA\"></param>\n/// <param name=\"headB\"></param>\n/// <returns></returns>\npublic ListNode GetIntersectionNode2(ListNode headA, ListNode headB)\n{\n    ListNode curA = headA, curB = headB;\n\n    while(curA!=curB)\n    {\n        curA = curA == null ? headB : curA.next;\n        curB = curB == null ? headA : curB.next;\n    }\n\n    return curA;\n}\n```\n\n# 环形链表\n\n[代码随想录 环形链表II](https://programmercarl.com/0142. 环形链表II.htm)\n\n[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/description/)\n\n（用时：2小时）\n\n## 思路\n\n前面链表相交也有涉及到环形链表的知识。前面理解了这里其实不是很难。\n\n要证明链表是否有环，和前面一样提到的一样：两个指针在环形链表中始终向前跑，若环形链表有环，那么两个指针一定会相遇。\n\n这里卡哥推导证明环形链表快慢指针如何相遇、两指针如何找入口才是重点难点。（时间问题推导就略过了，二刷时再自己推导）\n\n## 错误\n\n写的过程中犯了一些错误：\n\n1. fastNode和slowNode的初始值。\n2. while中，指针的遍历和if判断的前后位置。\n3. 为什么第二个while要嵌套在第一个while里面\n\n个人理解如下：\n\n- <u>fastNode和slowNode的初始值</u>\n\n  最近写的题中，初始值的问题总是会遇到问题。fast和slow两个指针都是从head头节点开始的，在赋初始值时，一般都是按照这个思路来，无需多想让后面的逻辑方便。当后续需要再回头修改至逻辑通畅即可。\n\n- <u>while中，指针的遍历和if判断的前后位置</u>\n\n  （这里其实也不是说犯错了，是自己有疑惑去尝试出来后得出来的想法。）两个指针的初始值都是head，如果不先走，那么刚开始就已经是指向同一个节点了。\n\n- <u>为什么第二个while要嵌套在第一个while里面</u>\n\n  最开始自己的思路：\n  在第一个while中，快慢指针向前探索，若两者相遇了，则说明有环。若没相遇，fastNode到链表末尾了，则没有环，返回null。\n  接着fastNode指向链表头节点，在第二个while中，让两个指针以同样的速度向前遍历，相遇的节点即为环形的入口。\n\n  测试后发现，示例1和3并不能通过，能力原因暂时也没找到原因。。。当时写的代码保留了下来：\n\n  ```c#\n  public ListNode DetectCycle(ListNode head)\n  {\n      ListNode fastNode = head, slowNode = head;\n  \n      while (fastNode != slowNode)\n      {\n          fastNode = fastNode.next.next;\n          slowNode = slowNode.next;\n  \n          if (fastNode == null || fastNode.next == null)\n          {\n              return null;\n          }\n      }\n  \n      fastNode = head;\n      while (fastNode != slowNode)\n      {\n          fastNode = fastNode.next;\n          slowNode = slowNode.next;\n      }\n  \n      return fastNode;\n  }\n  ```\n\n  现在时间不多，后续二刷应该会有新的理解。\n\n## 代码实现\n\n```c#\n public ListNode DetectCycle(ListNode head)\n {\n     ListNode fastNode = head, slowNode = head;\n\n     while (fastNode!=null && fastNode.next!=null)\n     {\n         fastNode = fastNode.next.next;\n         slowNode = slowNode.next;\n\n         if (fastNode==slowNode)\n         {\n             fastNode = head;\n             while(fastNode!=slowNode)\n             {\n                 fastNode = fastNode.next;\n                 slowNode = slowNode.next;\n             }\n             return fastNode;\n         }\n     }\n     return null;\n }\n```\n\n# 后记\n\n这四道题昨天（5.7）就开始写了，但能力有限吧一天下来只写完了3道题，记录也只整理回顾了前2道题的。\n\n现在开始难度有点上来了，愈发发现自己的算法能力拉下太多了。\n\n此后会将算法的练习作为每天最优先的任务。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习"],"categories":["computerStudy"]},{"title":"GAME101-Lecture05学习","url":"/2024/04/28/GAME101-Lecture05学习/","content":"\n# 回顾与引入\n\n前面学了各种变换。\n\n若要将一个三维的物体变成二维的平面上，需要进行一些变换。**（观测变换）**\n\n- 我们始终把摄像机的位置移动到一个“经典”的位置，然后把其他所有物体都和相机一起移动。**（视图变换）**\n- 当所有的物体已经有了一个“标准”的变换，可以将物体从三维投影成一个二维。**（投影变换）**\n\n此时做完观测变换后，所有物体都会在一个[-1,1]<sup>3</sup>上了。此时就需要让计算机根据这个信息，去“画”就是涉及到了光栅化。\n\n# 视锥\n\n![image-20240428132044174](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428132051.png)\n\n- 有时候人们更喜欢:**垂直视场**(fovY)和**纵横比**(假设对称性，即I=-r，b=-t)\n\n用长宽比和垂直的可视角度来定义一个视锥\n\naspect ratio（长宽比）\n\n垂直的可视角度（fovY）：图中红色线之间的夹角。\n\n![image-20240428132558069](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428132558.png)\n\n# 光栅化\n\n## 光栅化的一些定义\n\n![image-20240428132932974](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428132933.png)\n\n把图片画在屏幕的过程，我们就叫光栅化的过程。\n\n本门课上，我们可以认为像素是一个个的小方块，每个方块的颜色是一整个的颜色（即把像素当成最小的单位）\n\n![image-20240428133232164](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428133232.png)\n\n- 像素的索引是(x，y)的形式，其中x和y都是整数\n- 像素的索引从(0,0)到(宽-1,高-1)\n- 像素(x,y)以(x+0.5,y+0.5)为中心\n- 屏幕覆盖范围从(0,0)到(宽，高)\n\n![image-20240428133430607](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428133430.png)\n\n- 与z无关\n- 在xy平面上的变换:[-1,1]<sup>2</sup>到【0，宽】x【0，高】**(视口变换)**\n\n## 光栅显示设备\n\n### 示波器\n\n![image-20240428134712199](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428134712.png)\n\n早期的显示器（CRT）原理和示波器一样。\n\n原理大概是左侧的electron immeter上面会产生很多电子，电子经过加速后，会穿过显示设备，发生偏转打在屏幕上。\n\n早期会用到隔行扫描，就是这一秒处理奇数行、下一秒再处理偶数行这种。\n\n### 平板显示设备\n\n现在主要的显示设备，主要是LCD。LCD：液晶显示器。\n\n![image-20240428135224044](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428135224.png)\n\n- 原理:通过扭转偏振来阻挡或传输光\n- 背光照明(如荧光灯或LED)\n- 偏扭的中等强度水平\n\n大概意思就是，光通过这个中间的区域，然后扭转或阻挡关，可以让光的方向从竖直变成水平（右边的两个图就是State打开和关闭的情况对比）\n\n### 其他\n\nLED：发光二极管\n\n电子墨水屏\n\n# 三角形光栅化\n\n![image-20240428140013877](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428140013.png)\n\n- 为什么是三角形\n  最基本多边形\n  拆分其他多边形\n- 独特的属性\n  保证是平面的\n  轮廓分明的内部\n  三角形顶点插值的定义良好的方法(重心插值）\n\n![image-20240428140335627](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428140335.png)\n\n- 输入:投影在屏幕上的三角形顶点的位置\n- 输出:近似三角形的像素值集\n\n为了能够得到近似三角形的像素值集，我们需要得到像素点与三角形中心点的关系。其中一个方法就是采样。\n\n## 采样\n\n所谓采样，就是得到一个函数，输入位置即可得到函数的值。可以理解成把一个函数离散化的过程。 \n\n![image-20240428140823544](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428140823.png)\n\n- 抽样函数\n- 在一个点上对函数求值就是抽样。\n- 我们可以通过采样对函数进行离散化。\n- 采样是图形学的核心思想。\n- 我们的采样时间(1D)，面积(2D)，方向(2D)，体积(3D)。\n\n### 采样实现光栅化举例\n\n![image-20240428141009648](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428141009.png)\n\n给定一个三角形，我们需要确定的是那些像素的中心再三角形内。\n\n![image-20240428141211253](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428141211.png)\n\n定义一个函数inside，给定一个三角形和一个屏幕空间中任意的坐标，可得坐标是否在三角形内。\n\n![image-20240428141718637](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428141718.png)\n\ninside函数实现原理就是通过向量的叉乘。\n\n![image-20240428141836197](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428141836.png)\n\n点在边上是属于哪个三角形，是自己定义的，可以处理也可以不处理\n\n#### 光栅化函数的计算方式\n\n**（轴向）包围和**\n\n![image-20240428142113572](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428142113.png)\n\n无需将整个屏幕都走一遍，只需要在其可能有的区域内（图中的蓝色范围）中，进行光栅化即可。\n\n蓝色区域又称为（轴向）包围和，缩写成AABB。\n\n**增量三角形**\n\n![image-20240428142241571](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428142241.png)\n\n这种情况比较适合那种比较窄长的三角形（原本没有多少像素，但是包围和认为有很多像素）。\n\n### 实际的光栅化\n\n![image-20240428142918327](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428142918.png)\n\n可以发现其实实际的像素点根本不是一个方块。\n\n另外有一个现象，右侧图的绿色点相对的密度会比蓝红要高。这是因为人眼对绿色最为敏感。\n\n![image-20240428142923755](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/28/20240428142923.png)\n\n平时打印的时候，打印的检测系统会进行检测，图片颜色越多，打印的颜色就越黑。而屏幕的rgb则是相反。\n\n# 下节提示\n\n锯齿、走样问题\n\n# 总结\n\n今天主要讲的是光栅化的知识。\n\n在上节课中，通过观测变换（视图变换和投影变换），可以将三维的物体转化成二维的图像数据信息。\n\n这节课就是需要将这个信息“画”出来，这就叫做光栅化。\n\n理论上无论是怎样的图形，通过光栅化都能“画”在屏幕中。任何图形都可以分解成由三角形组成，因此课上主要以三角形为例，讲了三角形的光栅化。\n\n三角形光栅化中，最简单的方式就是采样。采样简单来说就是通过一个函数，将图形的位置信息传入，即可得到函数值，这个函数值个人理解就是在计算机中用于“画”的像素信息。\n\n但在实际应用中，光栅化会出现锯齿、走样的问题，下节课的主要目的，就是抗锯齿、防走样。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"GAME101-Lecture04学习","url":"/2024/04/19/GAME101-Lecture04学习/","content":"\n# 二维旋转矩阵的补充\n\n![image-20240419180446306](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419180446.png)\n\n第一行的式子，是上节讲到的二维的旋转矩阵（二维的变换不用齐次坐标表示的话，基本就是这种2\\*2的矩阵表示）\n\n第二行的式子，旋转-θ角。是将第一行的所有θ替换成-θ，然后化简得来的。\n\n- 观察可以发现，**旋转-θ的旋转矩阵，就是旋转θ的旋转矩阵的转置**。\n- 另外也可以，**旋转-θ的旋转矩阵，也是旋转θ的旋转矩阵的逆**。（第三行的式子。通过矩阵的定义，矩阵转成逆矩阵可知）\n- 从而可以得到性质：**在旋转里，旋转θ的旋转矩阵的转置 等于 旋转θ的旋转矩阵的逆**（在数学上，一个矩阵的逆等于它的转置，这个矩阵就是正交矩阵）\n- 如果想要让二维物体沿着相反的方向旋转相同的角度，那么写出一个正向旋转矩阵，然后转置即可。\n\n# 三维变换的补充\n\n![image-20240419182036017](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419182036.png)\n\n通过升维来表示三维变换。\n\n![image-20240419182154357](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419182154.png) \n\n和二维的变换一样，三维的仿射变换也是线性变换再平移变换的。\n\n## 缩放和平移（变换）\n\n![image-20240419182201446](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419182201.png)\n\n## 旋转（变换）\n\n### 旋转变换矩阵\n\n![image-20240419183923059](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419183923.png)\n\n三维的旋转分为绕着x、y、z三个轴旋转的情况。\n\n第一个式子中是绕着x轴旋转，可以发现：\n\n- x的值是不变的。因此在左上角3\\*3的线性变换矩阵中，其第一行和第一列都是100（图中蓝色框框）\n- y的值和z的值都是旋转的。因此左上角3\\*3的线性变换矩阵中，右下角的2\\*2的矩阵是变化的，这其实是因为y和z都旋转了相同角度。（图中红色框框）\n\n第三个式子中是绕着z轴旋转，和绕着x轴旋转的情况分析方式一样。\n\n第二个式子中是绕着y轴旋转，其式子就有些不同了。其旋转矩阵的值是其他的负值。\n\n- 坐标系的建立是用向量叉乘的方式建立的。本门课用的是右手螺旋定则判断正负（方向）。\n- 在确定x轴时可以用y叉乘z；z轴可以用x叉乘y。\n- 而y轴，只能用z叉乘x，x叉乘z是负值，所以其旋转矩阵的值是其他的负值\n\n### 欧拉角\n\n![image-20240419184148962](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419184149.png)\n\n- 从RX，Ry，Rz组成任意3D旋转?\n- 所谓欧拉角\n- 常用于飞行模拟器:滚转、俯仰、偏航\n\n任意的一个旋转，都可以写成绕x、y、z旋转的组合。\n\n三个轴旋转的旋转角，称为欧拉角。\n\n### 罗德里格斯旋转公式\n\n![image-20240419184530904](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419184530.png)\n\n简单来说就是将任意的旋转写成一个旋转公式，该公式可以将旋转“分解”到三个轴上。\n\n罗德里格斯公式提供了一个旋转矩阵，旋转矩阵定义了一个旋转轴n和旋转角度α。\n\n- 这里旋转轴默认过原点，那么就是起点是原点，方向是n，旋转角度是α旋转。\n- 如果要实现真正的绕任意轴旋转（即轴可以平移），那么就得平移这一条轴到能自转的情况（即让这个轴的起点与原点重合），先旋转（自传），转完再移回去。（所有的旋转都是自旋转，上节课提到的绕着某个点旋转也是得先平移让旋转点与原点重合，旋转完后再平移回去）\n- 图中公式最后的大N，就要看这个公式的推导。闫老师把推导过程的pdf发了出来，配合这个视频（[games101罗德里格斯旋转公式推导](https://www.bilibili.com/video/BV1qV411X79j/?share_source=copy_web&vd_source=8332072dc5586e92174abc96d6e4280f)）大概是明白了怎么推到的。（但自己推那是真搞不定，只能说数学水平真的决定计算机的上限。。。）\n- 推导过程中，有涉及到两个向量的叉乘。在进行两个向量的叉乘时，可以用矩阵的形式，因此才会出现最后面那个矩阵N。\n- （第二节的向量叉乘：）\n  ![image-20240419190235517](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419190235.png)\n  在三维中的两个向量的叉乘方法，就是图中第一条式子。而叉乘也可以写成下方第二条式子的样子（矩阵的形式)。\n\n## 四元数\n\n四元数是为了给旋转做差值才引入的。\n\n- 假设一个旋转矩阵是旋转15°，另一个是旋转25°。如果将两个矩阵加起来求平均，结果并不是20°。\n- 这是因为旋转矩阵不适合做差值。\n\n闫老师没有深入讲这个四元数，提了一嘴。后续自己会找些资料研究研究，毕竟unity里就有这个四元数。。\n\n# 观测变换\n\n变换其实是为了让三维的空间变成二维的图。\n\n## 视图变换\n\n### 引入\n\n![image-20240419195444944](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419195444.png)\n\n- 什么是视图转换\n- 想想怎么拍一张照片\n  --一找个好地方，安排人(**模式改造**)\n  --找一个好的“角度”来放相机(**视图变换**)\n  --“茄子！”(**投影变换**)\n\n模型视图投影变换，简称MVP变换。\n\n### 视图变换矩阵\n\n#### 矩阵概念定义\n\n![image-20240419195907247](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419195907.png)\n\n- 怎么进行视图变换？\n- 定义相机\n  --位置\n  --注视/凝视方向\n  --向上方向 (假设是 xx 观看)\n\n![image-20240419200208679](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419200208.png)\n\n- 关键观察\n  --如果相机和所有对象一起移动，“照片”将是相同的\n- 不如我们总是把摄像机转换成\n  --原点，在Y上，看-Z\n  --与相机一起变换对象\n\n![image-20240419200424122](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419200424.png)\n\n- 用 M<sub>view</sub> 变换相机\n  --它位于原点，在Y的上方，看-Z\n- M在数学中如何？\n  --将 e 平移到原点\n  --将g旋转到-Z\n  --将t旋转到Y\n  --旋转(g叉乘t 可以认为是图中绿色坐标轴) 至X\n  --很难写!\n\n#### 矩阵推导\n\n![image-20240419200939693](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419200939.png)\n\n- M<sub>view</sub>如何计算？\n  -- M<sub>view</sub> = R<sub>view </sub>T<sub>view</sub>\n- 平移到原点（T<sub>view</sub>就是平移矩阵）\n\n这里是先平移（T<sub>view</sub>平移矩阵）再线性变换（R<sub>view</sub>旋转矩阵）。\n\n对于R<sub>view</sub>，我们需要将视图的坐标系转成标准的坐标系。即g旋转到-Z；t旋转到Y；(g叉乘t)旋转到X。这样运算不好算，所以反过来让标准坐标系转成转到视图的坐标系。图中最后一行，就是用种思想进行的公式推导：\n\n- R<sub>view</sub>是视图的坐标系转成标准的坐标系的旋转矩阵。\n- R<sub>view</sub>直接求不好求，我们反过来，先求R<sub>view</sub><sup>-1</sup>。（前面二维矩阵补充提到，“在旋转里，旋转θ的旋转矩阵的转置 等于 旋转θ的旋转矩阵的逆”。）\n- R<sub>view</sub><sup>-1</sup>的求法则是和前面求“旋转矩阵的ABCD”一样，用特殊值法。\n- R<sub>view</sub><sup>-1</sup>求出来，R<sub>view</sub><sup>-1</sup> = R<sub>view</sub><sup>-T</sup>。\n- 此时让R<sub>view</sub><sup>-T</sup>再转置回去就可以得到R<sub>view</sub>。\n\n## 投影变换\n\n### 引入\n\n#### 投影\n\n![image-20240419203852807](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419203852.png)\n\n- 计算机图形学中的投影\n  --3D至2D\n  --正交投影\n  --透视投影\n\n上图的左下角是正交投影。正交投影并不会有近大远小的现象，透视会。\n\n上图的右下角是透视投影。原本平行的两条边，在这种投影下，会有相交。这里更像是人眼睛的效果。\n\n#### 摄像机的成像方式\n\n![image-20240419204016470](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419204016.png)\n\n左侧透视投影，摄像机放在某一个位置上看作一个点。以摄像机点为起点，做射线形成空间的一个锥体（视锥体）。在椎体中，通过“最远”和“最近”的设定，将“最远”和“最近”的区域的东西全显示在进出的图片上。\n\n### 正交投影\n\n![image-20240419204747544](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419204747.png)\n\n- 一个简单的方法来理解\n  --摄像头位于原点，看着-Z，向上看着Y(看起来很眼熟吗?)\n  --删除Z坐标\n  --将生成的矩形平移并缩放至[-1,1]<sup>2</sup>\n\n不管远处还是近处，全部放在一张图上。\n\n![image-20240419204932907](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419204932.png)\n\n我们要把一个立方体[l,r] x [b,t] x [**f,n**]映射到“标准(正则、规范、标准)” 的立方体[-1,1]<sup>3</sup>上\n\n空间中的任何一个立方体（最左侧的图），都可以通过平移、缩放等变换，变成一个标准的立方体（最右侧的图）。\n\nx轴表示左右（立方体的[l,r]），y轴表示上下（立方体的[b,t]），而z轴是远近（立方体的[**f,n**]。注意离我们更远，z的值应该是更大的，**f>=n**。这就是一些API 比如OpenGL用左手系）\n\n#### 正交矩阵\n\n![image-20240419205639065](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419205639.png)\n\n先做平移，再做缩放。\n\n### 透视投影\n\n#### 引入\n\n![image-20240419205909523](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419205909.png)\n\n- 最常见于计算机图形学、美术、视觉系统\n- 更远的物体更小\n- 不平行的。平行线汇聚成一点。\n\n![image-20240419210045840](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419210045.png)\n\n齐次坐标中，(x,y,z,1)乘上任意不为0的数，在三维中的坐标都是不变的，都是(x,y,z)。\n\n当(x,y,z,1)乘上z时，(xz,yz,z<sup>2</sup>)在三维中还是(x,y,z)。\n\n#### “挤压”投影\n\n![image-20240419211205862](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419211205.png)\n\n透视投影直接做或写出来比较困难。我们可以将远平面中间的位置，即这个Frustum（图形学中将远和近中间的区域叫做Frustum）从四棱竹的形状“挤”成立方体，然后再做正交投影即可。\n\n在“挤”的过程中，要做一些规定：\n\n1. 最近的平面不能变\n2. 要“挤”的z轴上的值不会变化（只向自己平面内中间收缩）\n3. 远平面的中心点也不会发生变化\n\n##### “挤压”矩阵\n\n![image-20240419211639970](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419211640.png)\n\n- 回忆一下关键思想：找出变换点(x’，y’，z’)和原始点(x，y，z)之间的关系\n\n通过相似三角形，可以得到变换点和原始点之间的关系。\n\n![image-20240419211756440](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419211756.png)\n\n图中第一个式子就是变换点和原始点之间的关系。\n\n图中第二个式子，是原始点到变换点的过程。(x,y,z,1)会被映射成最右边的向量。\n\n###### 矩阵推导\n\n![image-20240419212435348](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419212435.png)\n\n- 所以“挤压”(透视到正交)投影就是这样做的\n- 可以找出部分的M<sub>persp->ortho</sub>\n\nM<sub>persp->ortho</sub>就是挤压矩阵。\n\n图中第一个式子表示，用挤压矩阵M<sub>persp->ortho</sub>乘以原始点就可以得到最后的变换点。原始点和变换点都部分已知，求出挤压矩阵即可。\n\n图中第二个式子是求出的“挤压”矩阵（数学算出来的。。。）。第三行不知道，先放着。\n\n###### 矩阵第三行推导\n\n这里的推导，emmmm怎么说呢，还是在用特殊值推导。了解下推导过程就好。。\n\n![image-20240419213152008](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419213152.png)\n\n- 如何求出图中矩阵的第三行\n  --有什么有用的信息吗\n- 观察:第三排负责\n  --近平面上的任何点都不会改变\n  --远平面上的任何点的z都不会改变\n\n**信息1：近平面上的任何点都不会改变**\n\n![image-20240419213822775](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419213822.png)\n\n- 近平面上的任何点都不会改变。\n  用n代替z的值\n- 所以第三行一定会是(0 0 A B)的形式\n  n<sup>2</sup>与任何x y 上的值都无关\n\nn为近平面到摄像机的距离。\n\n这里就是先让原始点的z值为n，然后x y值依旧不知道。此时就会变成：矩阵第三行(? ? ? ?) 乘以 列矩阵(x,y,n,1) 等于n<sup>2</sup>。\n![image-20240419220446698](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419220637.png)\n即：?x+?y+?n+?=n<sup>2</sup>（矩阵的乘法，第i行分别乘以第i列的元素然后相加)\n\n然后观察 ?x+?y+?n+1=n<sup>2</sup> 这个式子，等号右边没有出现任何的x y，那么他们的系数只能是0。第三四个系数还是不知道，设为A B。因此就有了(0 0 A B)这个东西，从而能得到 An+B=n<sup>2</sup> 这个式子。\n\n**信息2：远平面上的任何点的z都不会改变**\n\n![image-20240419221059316](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419221059.png)\n\n和信息1一样，带入特殊值。f为近平面到摄像机的距离。\n\n在信息1推导出的(0 0 A B)基础上，带入f，可以得到Af+B=f<sup>2</sup>\n\n**联立解方程**\n\n![image-20240419221446659](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419221446.png)\n\n联立两个式子，用韦达定理解出了A B。此时就能够得到M<sub>persp->ortho</sub>“挤压”矩阵了。\n\n### 透视矩阵\n\n![image-20240419221607872](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419221607.png)\n\n通过“挤压”投影得到“挤压”矩阵后。先“挤压”再正交投影，就可以得到透视矩阵。\n\n# 总结\n\n## 二维三维补充\n\n今天先是对之前缩放、平移和旋转等这些变换在二维、三维上的一些补充。\n\n### 二维\n\n二维上是对旋转矩阵的补充。\n\n- 求物体旋转-θ时的旋转矩阵，发现R<sub>-θ</sub> = R<sub>θ</sub><sup>-T</sup>\n- 这里引出性质（理论上二维三维都通用）：**在旋转里，旋转θ的旋转矩阵的转置 等于 旋转θ的旋转矩阵的逆**。（数学上的正交矩阵）\n\n### 三维\n\n三维上时对缩放、平移和旋转变换的补充。\n\n- 三维的缩放和平移变换很简单，原理和二维的一致。\n- 三维的旋转变换，其会有绕x、y、z轴三个方向旋转的情况，对应的旋转矩阵都会不一样。\n- x和z的旋转矩阵分析方法一致。\n- 绕y轴的旋转矩阵比较特殊，其值是x 、y的旋转矩阵的负值。这是因为在右手系下，x叉乘y是-z。\n- 此外，还提及了四元数。由于矩阵不适合做差值，因此会用四元数。\n\n## 观测变换\n\n课上的重点是观测变换。观测变换有模型、视图、投影三种（简称MVP变换）\n\n个人理解模型变换像是“建模”这种，这里就不需要讨论。\n\n### 视图变换\n\n视图变换的主要原因是摄像机的摆放问题，抽象上来看，就是坐标系的建立和转换的问题。\n\n- 通过定义，我们规定了一套标准的坐标系。但是摄像机自身的坐标系并不一定与标准坐标系重合，这个时候我们需要进行坐标系的转换（视图变换）。\n- 视图变换时，要将视图（定义的摄像机的前后上下，原点，在Y上，看-Z）坐标轴通过平移、旋转等变换回到标准坐标系上。\n- 视图坐标的X轴是通过y和z叉乘得到，要将一个叉乘旋转比较麻烦。因此可以反过来，让标准坐标系旋转到视图坐标系上。接着通过前面的正交矩阵性质（在旋转里，旋转θ的旋转矩阵的转置 等于 旋转θ的旋转矩阵的逆），能够求出旋转矩阵。\n- 平移矩阵很简单，直接是原点的移动就可以得到\n- 视图变换是先旋转，再平移。通过旋转矩阵和平移矩阵，就可以算出视图矩阵。\n\n### 投影变换\n\n投影变换是将三维的画面投影到一张二维图像上，有正交和透视两种方式。\n\n#### 正交变换\n\n正交投影比较简单，平移变换加上缩放变换即可得到。同理正交矩阵也是通过平移矩阵和缩放矩阵就可以算出。\n\n#### 透视变换\n\n透视投影比较复杂。\n\n- 透视变换中为了不涉及坐标系之间的变换，引入了“挤压”的想法。透视投影做“挤压”投影，再做正交投影，就可以得到一张二维二维画像。\n- “挤压”投影的“挤压”矩阵推导起来比较复杂，后半节课都在干这个事情。\n- 总的来说，就是先利用相似三角形、变换点和原始点之间的关系和齐次方程的特性，得到出第三行以外的“挤压”矩阵值。\n- 第三行通过观察到的两个信息（挤压时近平面和远平面点的关系），带入特殊值解方程推出来的。\n- 算出“挤压”矩阵后，根据前面的正交矩阵，就能得到透视矩阵。\n\n# 课堂遗留问题\n\n在透视投影做“挤压”时，近平面的所有点不变，远平面的所有点z值不变。那么远近平面中间的点，经过“挤压”变换后，z值会如何变化呢？（这个点会被推向近平面，还是推向远平面）\n\n\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"算法练习day3","url":"/2024/04/19/算法练习day3/","content":"\n# 移除链表元素\n\n[代码随想录 移除链表元素](https://programmercarl.com/0203. 移除链表元素.htm)\n\n[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)\n\n（用时：0.5小时）\n\n## 普通方法\n\n普通的移除方法中，要将节点分为头结点和非头结点两类。\n\n- 如果头结点就是要移除的元素，那么直接让其next成为头节点即可（即缩头）\n- 如果是非头节点，让节点的前一节点的next指向要移除的节点的next即可。\n\n### 错误\n\n自己也没有想到，普通写的时候还出了好些问题，果然是不熟练啊。\n\n**错误：头节点不能用if，也要用while来筛除。**\n<u>如果用if，那就只判断了一次头节点，那万一头节点的下一个头节点也是要删的呢？</u>（也不知是不是unity的update写多了，写函数的时候脑子里一直是if也会循环hhh）\n\n## 虚拟头结点法\n\n虚拟头结点就是在原来的头结点前，增加一个头结点，让这个头结点暂时充当头结点。这样就消除头结点的特殊情况，少if判断。\n\n既然消除了头结点的特殊情况，题目也就变成了\n\n### 重点分析\n\n重点有以下三个：\n\n1. while中的判断条件？\n2. if判断的判断条件？\n3. if判断成立与否时，要做的操作、分别表示什么？\n4. currentNode的初始值？\n\n个人的理解如下：\n\n- if的判断\n\n  先考虑if的判断条件是因为while的判断条件要根据if的逻辑来写。\n  <u>当currentNodex.val等于要找的val移除当前节点，让需移除节点的前驱节点的next等于其下一节点（即frontNode.next = currentNode.next）。注意这里是知道需移除节点的前驱节点的，而这里用的又是单向链表，那就只有“未雨绸缪”，在它的前驱节点时就判断它是否要被移除，要的话让前驱节点实施才行。</u>\n  <u>不等于时，继续遍历。</u>\n\n- currentNode的初始值\n\n  currentNode的初始值就很简单了，根据前面这里的if判断，初始值应该是虚拟节点。\n\n- while中的判断条件？\n\n  所有的节点都是一类了，那么就只有这一个while了。while里的条件必定是让currentNodex停下来不继续遍历的。问题在于是currentNode还是currentNodex.next不等于null。\n  单独看while，这里两者好像都可以。但是我们得配合里面的if。<u>if判断的是currentNode.next.val是否为0，这个currentNode.next必须要是非null，.val才能引用，不然会报错。所以条件是currentNode.next!=null。</u>\n\n## 代码实现\n\n**普通方法：**\n\n```c#\n/// <summary>\n/// 普通不用虚拟头节点的方法\n/// </summary>\n/// <param name=\"head\"></param>\n/// <param name=\"val\"></param>\n/// <returns></returns>\npublic ListNode RemoveListElementFun2(ListNode head, int val)\n{         \n    //头节点\n    while (head != null && head.val==val)\n    {\n        head = head.next;\n    }\n\n    //非头节点\n    ListNode currentNode = head;\n    while (currentNode!=null && currentNode.next != null)\n    {\n        if (currentNode.next.val == val)\n        {\n            currentNode.next = currentNode.next.next;\n        }\n        else\n        {\n            currentNode = currentNode.next;\n        }\n    }\n    return head;\n}\n```\n\n**虚拟头节点法：**\n\n```c#\n/// <summary>\n/// 虚拟头节点法\n/// </summary>\n/// <param name=\"head\"></param>\n/// <param name=\"val\"></param>\n/// <returns></returns>\npublic ListNode RemoveListElementFun(ListNode head, int val)\n{\n    ListNode visHeadNode = new ListNode(val+1, head);\n    ListNode currentNode = visHeadNode;\n\n    //这里的判断条件要是currentNode.next!=null\n    while (currentNode.next!=null)\n    {\n        if (currentNode.next.val==val)\n        {\n            currentNode.next = currentNode.next.next;\n        }\n        else\n        {\n            //这里，放在否则里面\n            currentNode = currentNode.next;\n        }\n    }\n    r\n```\n\n# 设计链表\n\n[代码随想录 设计链表](https://programmercarl.com/0707.设计链表.htm)\n\n[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/description/)\n\n（用时：1.5小时）\n\n## 思路分析\n\n这道题是设计类的题目。设计“类”的话，方法和思路就很多了。所以写的时候就老是在优化，觉得这里能写的更好，然后就写了好久。。。（怎么有点职业病的感觉hhh）\n\n这道题就是对链表的增删查改。增删改都要在查的基础上，但是题目需要实现的函数只是给定下标，返回值就好，这在数组的增删改上挺好的（数组的查也就是下标引用hhhh），但在链表上，就有点鸡肋了。于是最开始先写了个查的函数，给定下标，返回指向该节点的指针（不知道会不会有什么内存方面的浪费？以往写类都不是为了不是很注重算法的东西，写的又不是c++，对这方面不是很敏感）\n\n删和改的函数没什么好说的，主要就是利用这个查的函数。\n\n增的函数，可考虑的就多了。总所周知链表的插入有头插和尾插两种。刚开始写的时候没有想到虚拟头节点的运用，就用头插和尾插的角度进行了分析。后来进行了迭代，增加了虚拟头结点，不分什么头插尾插了。\n\n- 01：定义三个函数。（如果没有虚拟节点，那么最简洁方便的就是这样）\n  第一个，查找节点函数。给定index，返回指向第index个节点的指针。\n  第二个，头插法函数。给定index，在该index前面插入新节点\n\n  ![image-20240420000254838](C:/Users/14638/AppData/Roaming/Typora/typora-user-images/image-20240420000254838.png)第三个，尾插法函数。给定index，在该index后面插入新节点。\n  ![](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419160023.png)\n\n  插入节点分为三种情况：\n  1.增加头结点：在原来的头结点上用头插法；\n  2.增加尾节点：在原来的尾节点上用尾插法；\n  3.中间的节点：自主选择是在第index个节点上用头插还是尾插）\n\n- 02：定义两个函数。这里省略了头插法的函数，因为有了虚拟节点。\n  第一个，同上\n  第二个，尾插法函数。同上\n\n  有了虚拟头结点，插入节点的三种情况的思路稍微改变了：\n  1.增加头结点：在虚拟头结点处用尾插法；\n  2.增加尾节点：在原来的尾节点上用尾插法；\n  3.中间的节点：自主选择。若在index前面插入，则在index-1上用尾插法。若在index后面插入，则在index上用尾插法）\n\n## 代码实现\n\n方案的修改是直接在代码上处理的，因此没有保留之前的版本。\n\n```c#\n public class MyLinkedList\n {\n     public class MyListNode\n     {\n         public int val;\n         public MyListNode next;\n         public MyListNode(int val = 0, MyListNode next = null)\n         {\n             this.val = val;\n             this.next = next;\n         }\n     }\n\n     public MyListNode visHeadNode;\n     public int listSize;\n\n     public MyLinkedList()\n     {\n         visHeadNode = new MyListNode(0, null);\n     }\n\n     /// <summary>\n     /// 得到指定下标的结点\n     /// </summary>\n     /// <param name=\"index\"></param>\n     /// <returns>返回节点指针，若下标不合法则返回null</returns>\n     public MyListNode FindNode(int index)\n     {\n         if (index<-1 || index>=listSize)\n         {\n             //Console.WriteLine(\"查找节点报错，下标不合法！(index: \" + index + \")\");\n             return null;\n         }\n\n         //Console.Write(\"查找节点成功！(val(\" + index + \"): \");\n\n         //指针p初始值指在index=-1的节点上\n         MyListNode p = visHeadNode;\n         //while的判断条件不用包含index=-1的情况，因为当要查找的index恰好是-1时，就无需向后查找了\n         while (index > -1)\n         {\n             p = p.next;\n             index--;\n         }\n\n         //Console.WriteLine(p.val);\n         return p;\n     }\n\n     /// <summary>\n     /// 头插法\n     /// </summary>\n     /// <param name=\"index\"></param>\n     /// <param name=\"val\"></param>\n     public void HeadInsertion(int index,int val)\n     {\n         MyListNode indexFrontNode = FindNode(index - 1);\n         if (indexFrontNode == null)\n         {\n             //Console.WriteLine(\"头插法报错，下标不合法！\");\n             return;\n         }\n\n         MyListNode newNode = new MyListNode(val, indexFrontNode.next);\n         indexFrontNode.next = newNode;\n         listSize++;\n     }\n\n     /// <summary>\n     /// 尾插法\n     /// </summary>\n     /// <param name=\"index\"></param>\n     /// <param name=\"val\"></param>\n     public void TailInsertion(int index,int val)\n     {\n         MyListNode indexNode = FindNode(index);\n         if (indexNode == null)\n         {\n             //Console.WriteLine(\"尾插法报错，下标不合法！\");\n             return;\n         }\n\n         MyListNode newNode = new MyListNode(val, indexNode.next);\n         indexNode.next = newNode;\n         listSize++;\n     }\n\n     /// <summary>\n     /// 得到指定下标的节点的值\n     /// </summary>\n     /// <param name=\"index\"></param>\n     /// <returns></returns>\n     public int Get(int index)\n     {\n         MyListNode indexNode = FindNode(index);\n         return indexNode == null ? -1 : indexNode.val;\n     }\n\n     /// <summary>\n     /// 在头结点处用头插法（即在虚拟头结点处用尾插法）\n     /// </summary>\n     /// <param name=\"val\"></param>\n     public void AddAtHead(int val)\n     {\n         //HeadInsertion(0, val);\n         TailInsertion(-1, val);\n     }\n\n     /// <summary>\n     /// 在尾节点处用尾插法增加节点\n     /// </summary>\n     /// <param name=\"val\"></param>\n     public void AddAtTail(int val)\n     {\n         TailInsertion(listSize-1, val);\n     }\n\n     /// <summary>\n     /// 在指定下标处用头插法增加节点\n     /// </summary>\n     /// <param name=\"index\"></param>\n     /// <param name=\"val\"></param>\n     public void AddAtIndex(int index, int val)\n     {\n         //HeadInsertion(index, val);\n         TailInsertion(index - 1, val);\n     }\n\n     /// <summary>\n     /// 删除指定下标处的节点\n     /// </summary>\n     /// <param name=\"index\"></param>\n     public void DeleteAtIndex(int index)\n     {\n         if (index<0 || index>=listSize)\n         {\n             return;\n         }\n\n         if (index==0)\n         {\n             visHeadNode.next = visHeadNode.next.next;\n         }\n         else\n         {\n             MyListNode indexFrontNode = FindNode(index - 1);\n             indexFrontNode.next = indexFrontNode.next.next;\n         }\n         listSize--;\n     }\n\n     /// <summary>\n     /// 打印目前的链表\n     /// </summary>\n     public void PrintList()\n     {\n         MyListNode p = visHeadNode.next;\n         Console.Write(\"目前的链表：\");\n         while (p!=null)\n         {\n             Console.Write(p.val + \" \");\n             p = p.next;\n         }\n         Console.WriteLine();\n     }\n }\n```\n\n# 反转链表\n\n[代码随想录 反转链表](https://programmercarl.com/0206.反转链表.htm)\n\n[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)\n\n（用时：0.5小时）\n\n## 双指针法\n\n单向链表的节点的前驱节点自己是不知道的，因此在遍历和更改的时候，需要定义多个指针，防止断链的情况。画图分析：\n![image-20240419164846826](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/19/20240419164846.png)\n随意找中间的某个节点进行翻转，发现至少需要一个cur指针用于向前遍历，front指针记录cur的前驱节点以及一个back指针记录后驱节点防止反转后cur无法进行遍历（看视频的时候，也有说back是临时的，所以不算第三个指针。)\n\n### 重点分析\n\n这道题有几个需要注意的重点：\n\n1. back指针记录cur后驱节点应在改变cur指针next朝向前进行，不然会cur处断链，cur后续无法继续遍历。\n2. front指针的更新应该在cur指针的更新之前，因为此时的front指针的next已经这次循环之前就被改了朝向。\n\n## 递归法\n\n能够被循环迭代实现的，一般都能写成递归。\n\n这道题由于已经给出了调用函数的定义，因此无法在其基础上改成递归函数。定义一个新的函数，用于处理递归的逻辑。\n\n- 递归的参数：递归函数的参数是要一直改变的值。在循环中，cur和 front的值一直在更新（back是临时的），因此递归的参数就是cur和front。\n- 递归的出口：递归函数的出口就是循环终止的条件。在循环中，while的终止条件是cur为null，因此这就是递归的出口。\n- 递归要处理的逻辑：递归的逻辑就是循环要做的东西。在循环中，其实是一直重复着临时指针back指向cur后驱节点、改变cur的next朝向和front、cur更新的操作。那在递归了也如此，只是注意front、cur的更新要在给递归函数传参时体现。\n\n## 代码实现\n\n**双指针法：**\n\n```c#\n/// <summary>\n/// 双指针法\n/// </summary>\n/// <param name=\"head\"></param>\npublic ListNode ReverseListFun1(ListNode head)\n{\n    ListNode frontNode, curNode, backNode;\n\n    frontNode = null;\n    curNode = head;\n    \n    \n    while(curNode != null)\n    {\n        //更新临时指针\n        backNode = curNode.next;\n\n        //改变当前节点的next朝向\n        curNode.next = frontNode;\n\n        //更新指针\n        frontNode = curNode;\n        curNode = backNode;\n    }\n\n    return frontNode;\n}\n```\n\n**递归法：**\n\n```c#\n/// <summary>\n/// 递归法\n/// </summary>\n/// <param name=\"head\"></param>\npublic ListNode ReverseListFun2(ListNode head)\n{\n    return Reverse(null, head);\n}\n\n/// <summary>\n/// 递归法的递归函数\n/// </summary>\n/// <param name=\"frontNode\"></param>\n/// <param name=\"curNode\"></param>\n/// <returns></returns>\npublic ListNode Reverse(ListNode frontNode,ListNode curNode)\n{\n    if (curNode==null)\n    {\n        return frontNode;\n    }\n    else\n    {\n        ListNode backNode = curNode.next;\n        curNode.next = frontNode;\n        return Reverse(curNode, backNode);\n    }\n}\n```\n\n","tags":["数据结构 算法练习"],"categories":["computerStudy"]},{"title":"unity实现模拟鼠标测量距离","url":"/2024/04/18/unity实现模拟鼠标测量距离/","content":"\n# 思路分析\n\n做项目时，有一个测量距离的功能需要实现：假设屏幕中有四个点ABCD，它们之间可以互相到达。提前设置好了邻接矩阵以及他们之间的路径长度。现在需要用鼠标模拟点与点之间的测量过程。\n\n功能有些复杂，自己学艺不精，想出来的方案比较粗糙：\n\n- 首先需要解决\n"},{"title":"算法练习day2","url":"/2024/04/18/算法练习day2/","content":"\n# 有序数组的平方\n\n[代码随想录 有序数组的平方](https://programmercarl.com/0977.有序数组的平方.html)\n\n[力扣 977.有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)\n\n（用时：0.3小时）\n\n这道题很简单，可以用双指针法或者暴力破解。\n\n## 双指针法\n\n本题允许新构建数组，然后返回值可以是新的数组，因此个人认为才会比较简单。但如果不允许构建数组呢？\n\n- 题目提供的是一个有序的升序数组，数组中也会有负数和零。整个数组都平方后，数组的大小趋势应该是从两头向中间递减的，如图：\n  ![image-20240418171625395](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/18/20240418171632.png)\n- 指针head和tail顾名思义，分别从数组的头和尾开始遍历。\n- 在遍历的时候，比较头和尾的平方大小，大的放入新数组的尾部，不断比较放入，即可得到一个新的升序的平方数组。\n- 注意一下新数组是从后往前赋值的，因此新数组的下标初始值应为数组长度-1.\n\n## 暴力破解\n\n暴力破解就更简单了。\n\n- 将原数组按顺序平方后的值放入新数组中。\n- 再对新数组排序既可。\n\n## 代码实现\n\n**暴力破解：**\n\n```c#\n/// <summary>\n/// 暴力破解\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <returns></returns>\npublic int[] SquareOfArrayFun2(int[] nums)\n{\n    int[] ans = new int[nums.Length];\n\n    for (int i = 0; i < nums.Length; i++)\n    {\n        ans[i] = nums[i] * nums[i];\n    }\n\n    Array.Sort(ans);\n\n    return ans;\n}\n```\n\n**双指针法：**\n\n```c#\n/// <summary>\n/// 双指针法\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <returns></returns>\npublic int[] SquareOfArrayFun1(int[] nums)\n{\n    int[] ans = new int[nums.Length];\n    int head = 0, tail = nums.Length - 1, arrIndex = nums.Length;\n    \n    while(head <= tail)\n    {\n        if (nums[head]* nums[head] < nums[tail]* nums[tail])\n        {\n            ans[--arrIndex] = nums[tail] * nums[tail];\n            tail--;\n        }\n        else\n        {\n            ans[--arrIndex] = nums[head] * nums[head];\n            head++;\n        }\n    }\n\n    return ans;\n}\n```\n\n# 长度最小的子数组\n\n[代码随想录 长度最小的子数组](https://programmercarl.com/0209.长度最小的子数组.html)\n\n[力扣 209.长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n\n（用时：0.5小时）\n\n这道题其实难度不高，但是引入了滑动窗口的思想。\n\n\n\n## 滑动窗口\n\n滑动窗口是一个抽象的概念，在不同地方具体是什么都不太也一样。\n\n- 个人认为窗口其实就是一块“区域”，像是数学的“区间”。\n- 所谓滑动，个人认为是这块区域的起始和终点是可变意思，但是起点和终点始终会保持着起点<=终点这个条件（起点和终点的意义也是这样固定了）。\n- 合起来，滑动窗口可以认为就是一段可变的区间，变化的条件、区间要满足的要求都是人定的。利用这个思想，可以解决一些计算机的问题。\n\n（题外话：滑动窗口也让我想起来计网中的那个滑动窗口hhhh，思想都是很互通呢。）\n\n## 滑动窗口法\n\n本题本质其实就是要找数组中连续的数字，这些数字连在一起，可以看成一片“区域”。\n\n- 程序中，可以用两个指针（也不一定是真的指针）表示窗口的起点和终点。让起点和终点按照我们的要求改变，就可以实现查找区域的想法。\n- end指针先向后探索，从start到end这块区域的数相加如果>=target，那么就说明这块区域是符合要求的“子列”。\n- 由于要找最小子列长度，那么单单符合要求并不够，还得比较符合要求的所有子列的长度。此时可以靠start，从目前已经符合要求的start到end的区间中，后移减短子列长度。\n\nstart和end配合操作，总结来说：\n1.**先找到符合要求的子列**\n2.数一定要连续。依次**让起点往后挪，尝试是否有更加“完美”的子列。**\n\n### 重点思考\n\n写的时候，需要重点考虑以下问题：\n\n- 窗口的start如何定义和改变？\n- 窗口的end如何定义和改变？\n\n个人的一些理解：\n\n- 窗口的start如何定义和改变？\n\n  <u>start指针主要是用来在现有符合条件的子列上，缩短“优化”子列长度。</u>\n  <u>start只有在 s(当前子列和)>=Target时，才能start++以后移</u>\n  <u>start能够一直后移，一定是start++后，s(当前子列和)>=Target依旧成立。</u>（不用担心出现start>end而条件还成立的情况。因为s-nums[start]和start++是先后进行的，s的初值是0，target和数组都是正整数，0<正整数。）\n\n- 窗口的end如何定义和改变？\n\n  <u>end指针主要是用于寻找符合条件的子列，不负责“优化”。</u>\n  <u>end只有在找到s(当前子列和)>=Target时，才会停下来，让start“优化”。</u>\n  <u>end的边界条件是数组长度。</u>\n\n### 错误思考\n\n- 本题写的时候，思路上没有什么阻碍，实现上也是。\n- 但在一个地方出了问题：int的最大值。\n- 以前写习惯了，int的最大值直接定成65535，其实不是。\n- C#中可以用int.MaxValue来替代。\n\n## 暴力破解法\n\n暴力破解就是双层循环，遍历出所有的可能。\n\n## 代码实现\n\n**滑动窗口法：**\n\n```c#\n/// <summary>\n/// 滑动窗口法\n/// </summary>\n/// <param name=\"target\"></param>\n/// <param name=\"nums\"></param>\n/// <returns></returns>\npublic int SmallSubarrayFun1(int target, int[] nums)\n{\n    int start = 0, end = 0, subLen = int.MaxValue, s = 0;\n    while(end< nums.Length)\n    {\n        s += nums[end];\n        while (s>=target)\n        {\n            //先判断并更新目前最短的子列长度\n            if (end - start + 1 < subLen)\n            {\n                subLen = end - start + 1;\n            }\n            //接着尝试缩短窗口（start后移）\n            \n            s -= nums[start];\n            start++;\n        }\n        //缩短窗口完毕，继续让end向后探索\n        end++;\n    }\n    if (subLen== int.MaxValue)\n    {\n        return 0;\n    }\n    else\n    {\n        return subLen;\n    }\n}\n```\n\n# 拓展思考\n\n如果Target不一定是正整数或数组里包含负数或0呢？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习"],"categories":["computerStudy"]},{"title":"算法练习day1补充","url":"/2024/04/18/算法练习day1补充/","content":"\n# 前言\n\n昨天第一天时间太赶，没来得及把剩下的一题看了，今天补回来。\n\n# 移除元素\n\n[代码随想录  移除元素](https://programmercarl.com/0027.移除元素.html)\n\n[力扣 27.移除元素](https://leetcode.cn/problems/remove-element/description/)\n\n（用时0.5小时）\n\n这道题的解法有两种，一种是暴力破解，一种是快慢指针法。\n\n注意题目要求空间复杂度是O(1)，这表明需要在同一个数组中进行处理。\n\n## 暴力破解\n\n暴力破解很简单，两层嵌套循环。\n\n- 外层循环用于遍历整个数组，如果找到需要移除的元素，则开启内层循环。\n- 内存循环用来将该需移除元素后面的所有元素向前挪一位（题目要求元素原顺序不可变）。这样的时间复杂度大概是O(n方)\n\n### 注意重点\n\n暴力破解时，有个地方要注意：所有元素移完位置后，外层循环的循环遍历（一般是那个i），要 i-- 。\n\n- i--主要是因为，我们原本在这个第i位上发现他是要移除的，才将后面所有的元素前移一位。\n- 移完后第i位已经不是原来的那个元素了，此时需要再判断移动后的第i位是不是恰好也是要移除的元素\n- 即**可能会有连续几个元素都是要移除的**\n\n## 快慢指针法\n\n快慢指针需要小绕一下。\n\n- 快指针是对整个数组进行探索遍历，慢指针是对新的数组进行赋值遍历\n\n- 如果反应不过来，可以先把慢指针当成一个新的空的数组的指针。快指针对旧的数组进行遍历：\n\n  ​\t1.如果不是需要移除的元素，则利用慢指针加入新数组的空位中，慢指针向后移一位。快指针后移一位。\n\n  ​\t2.如果是需要移除的元素，新数组和慢指针不做处理。快指针后移一位。\n\n- 两个数组的想好了后，一个数组就简单了。只是将两个指针放到了同一个数组上进行处理。慢指针一定会等于或慢于快指针，因此不会出现问题。\n\n### 注意重点\n\n快慢指针法在写的时候，重点要考虑以下几点：（\n\n- arr[fastIndex] != val时，要做什么？\n- arr[fastIndex] = val时，要做什么？\n- return slowIndex？ 还是slowIndex+1？ 还是slowIndex-1？\n\n以下是个人的一些想法：\n\n- nums[fastIndex] != val时，要做什么？\n\n  <u>不等于时，表示该值不用被跳过，slowIndex要让其放入新数组。更新slowIndex，fastIndex继续探索既可。</u>\n\n- nums[fastIndex] = val时，要做什么？\n\n  <u>等于时，表示该值要被跳过，slowIndex不能放入新数组。让fastIndex继续向前探索即可。</u>\n\n- return什么？\n\n  <u>slowIndex始终是等待赋值的下一位，因此只用return slowIndex即可。</u>\n\n## 代码实现\n\n### 暴力破解\n\n```c#\n/// <summary>\n/// 暴力破解法\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <param name=\"val\"></param>\n/// <returns></returns>\npublic int RemoveElementFun2(int[] nums, int val)\n{\n    int cnt = 0;\n    for (int i = 0; i < nums.Length - cnt; i++)\n    {\n        if (nums[i] == val)\n        {\n            for (int j = i + 1; j < nums.Length - cnt; j++)\n            {\n                nums[j - 1] = nums[j];\n            }\n            cnt++;\n            i--;\n        }\n    }\n    return nums.Length - cnt;\n}\n```\n\n### 双指针法\n\n```c#\n/// <summary>\n/// 快慢指针方法\n/// </summary>\n/// <param name=\"nums\"></param>\n/// <param name=\"val\"></param>\n/// <returns></returns>\npublic int RemoveElementFun(int[] nums, int val)\n{\n    int fastIndex, slowIndex;\n    fastIndex = slowIndex = 0;\n\n    while (fastIndex < nums.Length)\n    {\n        if (nums[fastIndex] != val)\n        {\n            nums[slowIndex] = nums[fastIndex];\n            fastIndex++;\n            slowIndex++;\n        }\n        else\n        {\n            fastIndex++;\n        }\n    }\n\n    return slowIndex;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习"],"categories":["computerStudy"]},{"title":"unity游戏中测量结果归一化处理","url":"/2024/04/18/unity游戏中测量结果归一化处理/","content":"\n# 需求分析\n\n在UGUI下，提前知道两点（设为A、B）之间的距离，以及他们的屏幕坐标。\n\n现在想要实现，鼠标从A点出发移动的偏移值映射到两点之间距离的区间中（即将鼠标相对A点的偏移数据处理到AB距离的范围内，以达到模拟真实测量的效果。\n\n（例如：让玩家点击A点后出现，从A点延申到鼠标上有一条线，通过拉线来实现测量的效果。）\n\n时间有点紧迫，也没有细想这样实现的可用性啥的。真诚希望有大佬指教！\n\n# 归一化公式\n\n使用的公式出处：[将数据归一化到任意区间范围的方法_数据 处理到 指定范围内-CSDN博客](https://blog.csdn.net/irober/article/details/115601223)\n\n# 代码实现\n\n**归一化函数：**\n\n```c#\n/// <summary>\n/// 将测量结果归一化\n/// </summary>\n/// <param name=\"min\">样本数据的最小值</param>\n/// <param name=\"max\">样本数据的最大值</param>\n/// <param name=\"left\">区间的左边界</param>\n/// <param name=\"right\">区间的有边界</param>\n/// <param name=\"value\">需要归一化的测量结果</param>\npublic float MeasureNormalization(float min,float max,float left,float right,float value)\n{\n    float temp;\n    if (min>max)\n    {\n        temp = min;\n        min = max;\n        max = temp;\n    }\n    if (left>right)\n    {\n        temp = left;\n        left = right;\n        right = temp;\n    }\n\n    return left + (right - left) / (max - min) * (value - min);\n}\n```\n\n**调用举例：**\n\n```c#\n//将鼠标的坐标转为屏幕坐标系的坐标\nRectTransformUtility.ScreenPointToLocalPointInRectangle( UI的画布RectTransform, 鼠标自己坐标系下的当前坐标, null, out 接收鼠标在屏幕坐标系下的坐标的变量);\n\n//归一化后的结果\nans = MeasureNormalization( 0, AB点屏幕坐标下的距离, 0, AB点认为规定要测量出来的距离, 鼠标在屏幕坐标系下的坐标);\n```\n\n\n\n\n\n","tags":["unity"],"categories":["computerStudy"]},{"title":"unity中鼠标与物体的交互","url":"/2024/04/18/unity中鼠标与物体的交互/","content":"\n# unity内置方法\n\nunity内置的OnMouseOver等方法，原理是利用射线检测。\n\n前提条件一是要有collider，二是摄像机要能够进行射线检测。\n\n- 在做的项目中，有个UGUI的2d物体无法使用OnMouseOver，猜测是因为摄像机实际上不是对着UI的。\n- **OnMouseOver这类方法，不适合对UI的拖拽进行处理，适合对3d物体的拖拽进行处理。**\n\n# unity EventTrigger组件\n\nEventTrigger的使用方法有很多，一是手动添加EventTrigger组件，然后对事件函数进行拖拽。二是可以重写接口。\n\n重写接口时，要注意，IBeginDrawHandler和IEndDrawHandler一定要有IDrawHandler才能实现。\n\n在鼠标拖拽时，UI物体与鼠标相差太远，原因可能是因为Canvas的Scale数值不是1，这时候要么就全调成1，要么就在脚本中除以相应的画布尺寸大小系数。\n\n# 学习视频链接\n\n学习时看的视频链接：【【盘点】Unity常用的三种拖拽方法（内置方法 + 接口 + Event Trigger组件）】 https://www.bilibili.com/video/BV1W541147GK/?share_source=copy_web&vd_source=8332072dc5586e92174abc96d6e4280f\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["unity"],"categories":["computerStudy"]},{"title":"GAME101-Lecture03学习","url":"/2024/04/17/GAME101-Lecture03学习/","content":"\n# 变换引入目的\n\n建模、3D转2D（投影）\n\n![image-20240417214811477](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417214818.png)\n\n# 缩放（变换）\n\n![image-20240417233641105](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233641.png)\n\n![image-20240417233647324](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233647.png)\n\n![image-20240417233701179](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233701.png)\n\n# 反射/对称（变换）\n\n![image-20240417233817350](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233817.png)\n\n# 切变\n\n![image-20240417214916402](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417214916.png)\n\n- 提示:\n- 水平位移在y=0处为0\n- 水平位移在y=1处为a\n- 垂直位移总是0\n\n整体：只是水平方向发生移动，竖直方向没有变化\n\n上面的边：水平方向移动的都是a\n\n中间的位置（y=0.5时）：水平方向移动都是0.5a\n\n总结可以认为，水平位置移动了a*y。x' = x+ay,y'=y，写成矩阵形式就是右下角的样子。\n\n# 旋转（变换）\n\n我们自己规定，任何旋转没有特地说明，都认为是绕着原点(0,0)旋转，旋转方向默认逆时针。\n\n## 旋转矩阵\n\n![image-20240417215439805](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417215439.png)\n\n## 旋转矩阵推导过程\n\n![image-20240417220007752](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417220007.png)\n\n列向量左乘矩阵\n\n- 首先，(x,y)--->(x',y')肯定是x和y分别乘以了某些系数，从而才能达到(x',y')的效果。（前面切变那里的分析过程\n- 按照切变的例子，向量(x',y')可以转化成向量乘矩阵的形式就是闫老师写出的那个ABCD的式子（图中黑色箭头尾端的式子）。此时问题就转化成了解出ABCD的值。\n- 要解矩阵，可以通过到带入特殊值的方式。最上面靠右的图就是闫老师演示的某种特殊情况，(1,0)--->(cosθ,sinθ)，将其带入待解式子即可（图中黑色部分）\n- 要完全解出来四个参数ABCD，找两个特殊解即可。\n\n（弹幕中有补充一般性的问题，闫老师这种解法是可以的）\n\n# 线性变换\n\n![image-20240417221233333](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417221233.png)\n\n如果能把变换写成上图的这种形式（即用矩阵乘以输入的坐标可以得到输出的坐标），这种变换叫做线性变换。\n\n即对于一个变换，用一个矩阵表示。\n\n# 齐次坐标\n\n**引入齐次坐标的主要原因是平移变换比较特殊，简单的表示成前面所需的一个矩阵乘以一个向量的形式，而不是让平移变换成为一个特殊的变换。**\n\n后续的推导起到帮助理解的作用。\n\n## 引入目的\n\n![image-20240417221910780](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417221910.png)\n\n![image-20240417221925820](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417221925.png)\n\n- 平移不能以矩阵形式表示(所以，翻译不是线性变换!)\n- 但我们不希望翻译成为一个特例\n- 是否有一种统一的方式来表示所有的转换?成本是多少\n\n平移的变换主要是加法，看着简单，但是像前面那样，通过矩阵的解法列出的话，会很复杂（如第二幅图）。（弹幕中说，这在线性代数中，叫做非齐次方程）\n\n并且，由于平移的变换中，矩阵乘法后面还要做一个加法，因此平移变换不是线性变换\n\n## 齐次坐标的解决方案\n\n用齐次坐标，通过增加一个数（一个维度）让平移变换写成矩阵乘以向量的形式（其他的线性变换也可以这么写），如下图(x',y',w')的变换：\n\n![image-20240417223038073](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417223038.png)\n\n## 齐次的“保护性”\n\n向量表示的是方向性，向量平移表示的任是同一个向量，这说明向量具有平移不变性。\n\n那么如果有一个向量(x,y,0)，经过矩阵的变换，若想让他不变（依旧是(x+t,y+t,0)）。可以增加一个0（一个维度）保护他。\n\n![image-20240417223410477](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417223410.png)\n\n- 齐次坐标\n- 如果结果的w坐标为1或0，则有效操作\n\n在空间中（二维或三维），向量加上向量（三角形法则）得到一个新的向量。\n\n点减去点，得到新的向量。\n\n点加上向量，点沿着一条线移动，移动到一个新的点上。\n\n点加点的扩充定义：在二维中，当w不等于0，可以让其转成（x/w,y/w,1)，w=1就可以表示成一个二维的点(x/w,y/w)。\n\n因此点加点得到的是这两个点的中点\n\n上述阐述了，最后一位是0，不仅保证了其平移不变性，还能保证在操作下是对的。\n\n\n\n# 仿射变换\n\n![image-20240417224820539](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417224820.png)\n\n图中上方的式子，我们称为仿射变换。\n\n在图中下方的式子中，我们用一个式子（齐次坐标）表示了所有的变换\n\n用齐次坐标去**表示二维的仿射变化**时，可以发现：\n\n- 矩阵的最后一行永远是001\n- 平移永远是写在最后一列的头两个数上\n- 前两列的前两个元素是原来线性变换的部分\n\n# 2D（二维）变换\n\n![image-20240417225121008](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225121.png)\n\n缩放变换中，没有平移，因此最后一列头两个数是00。\n\n旋转变换中，平移和缩放同理。\n\n平移变换中，没有经过线性变换，左上角是单位矩阵1001，有平移因此最后一列头两个数是tx ty。\n\n# 逆变换\n\n![image-20240417225508580](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225508.png)\n\n逆变换在矩阵中，就是乘以逆矩阵。\n\n# 组合变换\n\n![image-20240417225649265](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225649.png)\n\n- 如何才能从左边变换成右边？\n\n![image-20240417225656282](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225656.png)\n\n- 先平移再旋转，发现不可行\n\n![image-20240417225705466](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225705.png)\n\n- 先旋转在平移，发现可行\n\n通过上面的例子，可以知道\n\n- 复杂的变换可以通过简单的变化得到\n- 变换的顺序很重要\n- 这和矩阵的乘法一致，矩阵没有交换律\n\n![image-20240417225940346](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225940.png)\n\n向量默认时一个列矩阵，因此做变换的时候需要从左往右乘。（如图，列矩阵xy1先做旋转再做平移，因此先左乘一个R再左乘一个T）\n\n## 推广\n\n![image-20240417230313249](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417230313.png)\n\n- 仿射变换序列A1、A2、A3,…由矩阵乘法构成\n- 对性能非常重要！\n- 对n个矩阵进行预相乘以获得表示组合变换的单个矩阵\n\n先将前面的矩阵全部乘完，乘完还是一个3\\*3的矩阵。这说明一个3\\*3的矩阵可以表示很复杂的变换。\n\n# 分解变换\n\n![image-20240417230947003](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417230947.png)\n\n- 如何围绕一个给定的点c旋转?\n- 将中心转换为原点\n- 旋转\n- 移动回来\n\n相当于在二维中，图形绕着任意一个点旋转，都可以转换成：先把图形平移使得旋转点与原点重合，再绕原点旋转，然后再把旋转后的图形移回相同的参数\n\n# 3D变换\n\n三维空间的变换，可以类比二维的。\n\n注意区别，三维的点和向量增加一个数（升维）后，并不是四元数，四元数是专门用来表示旋转的。\n\n![image-20240417231500879](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417231500.png)\n\n- 再次使用齐次坐标\n\n![image-20240417231558326](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417231558.png)\n\n最后一行还是0001\n\n平移：依旧是在最后一列\n\n线性变换：左上角的3\\*3矩阵\n\n# 课堂启发\n\n可以把仿射变换写成一个简单的矩阵形式，矩阵表示线性操作和平移操作。\n\n# 课堂问题\n\n闫老师留下来的问题：在三维的变换中，矩阵应用在xyz这个三维点上，是先平移还是先线性变换呢？\n\n解答：可以看前面，2D下仿射变换的式子，是线性变换（矩阵乘以向量）加上平移变换。因此是先线性变换再平移变换。\n\n# 总结\n\n今天讲的是各种变换，前面所有的变换都是以2D为例的，3D其实也是同理。\n\n缩放、对称、旋转等这些变换，能够直接用矩阵乘以向量的形式表示，称为线性变换。\n\n平移不能以矩阵乘以向量表示，并不是平移变换。其形式是矩阵乘以向量加上一个矩阵，可以称之为仿射变换。\n\n如果将平移看作特殊的变化，那又太过麻烦。为了让所有的变换具有统一性，引入了齐次坐标的知识。\n\n齐次坐标能够通过加一个数（升维）的方式，通过齐次坐标来表示仿射变换。其次坐标也可以表示线性变换。\n\n因此，能够用齐次坐标的方式，将所有的变换转变成矩阵与向量的形式。\n\n将单一的变换累加，就是组合变换。组合变换中，变换的顺序很重要。\n\n在组合变换中发现，先将所有的变换矩阵相乘，还是能得到一个矩阵，这说明任何复杂的变换都能用一个矩阵来表示。\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"算法练习day1","url":"/2024/04/17/算法练习day1/","content":"\n# 前言\n\n大二开始定下实践项目的主方向后，对于数据结构、算法这一块基本就是停滞状态了。\n\n选择游戏方向后，unity和C#的实际项目对于算法方面的要求并不多。实习需要去大厂，并且为了进一步提高自己的能力，决定接下来的日子里苦练算法。\n\n以前练习算法这方面，用的都是C、Java这类。用C#写还是头一次，在练习算法的同时，增进自己对C#的使用熟练度，也是一举两得。\n\n接下来的日子，打算跟着卡哥的《算法随想录》刷题。根据http://t.csdnimg.cn/l8b7i，这篇大哥的博客，每天进行练习。自己练习确实得要很大的毅力和决心，希望自己能够坚持下来，共勉~\n\n# 二分查找\n\n[代码随想录 二分查找](https://www.programmercarl.com/0704.二分查找.html)\n\n[力扣 704.二分查找](https://leetcode.cn/problems/binary-search/)\n\n（用时：1.5小时）\n\n写的过程中出现了错误，思考了10分钟无法解决后，找了参考代码进行了纠错。错误如下：\n\n- 错误一：target < arr[mid]写成了target < mid\n- 错误二：写成了递归（也不算是错误，递归也能实现二分查找。但写的混合了递归和非递归，导致写的非常混乱！这也是对递归没有很好的理解。后来理清非递归后，重新写了下递归，一起放在后面了）\n- 错误三：左闭右开时，right = mid写成了right = mid-1\n\n## 错误复盘\n\n**错误一分析：**mid是一个下标，在target是一个值，比较的时候应是拿值比较。这里是对mid和target的关系没有更加深刻的理解，当查找到时，两者关系：target=arr[mid]\n\n**错误二分析：**写成了递归这个错误就emmmm，其实是可以写成递归的。递归之前也一直是迈不过去的坎，导致这里先入为主了。递归是写出来了，但并不是题目格式的要求。。每天的时间有限，第一遍刷更侧重于复习回顾理解，第二遍再拓展深究。\n\n**错误三分析：**\n\n- 卡哥视频二分查找有两个重点，一是while的判断条件，二是if里的判断条件。\n\n- while的判断条件看开闭区间，看left=right是否能取即可。\n\n- if判断条件也是看开闭区间，这里是看left是否能等于区间左侧、right是否能等于区间右侧\n\n  例如，假设  区间为[i,j)   mid=(i+j)/2，left=mid、左闭是可取的，right=mid、右开不可取\n\n  ![image-20240417185239607](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417185239.png)\n\n## 正解\n\n**左闭右闭：**\n\n```c#\n/// <summary>\n/// 左闭右闭\n/// </summary>\n/// <param name=\"arr\"></param>\n/// <param name=\"target\"></param>\npublic int Search1(int[] arr, int target)\n{\n    int mid, left, right;\n    left = 0;\n    right = arr.Length - 1;\n    //左闭右闭，left可以等于right\n    while (left <= right)\n    {\n        mid = (left + right) / 2;\n        if (target < arr[mid])\n        {\n            //右闭，mid可以取右边界，这里不用重复比较右边界，所以减一\n            right = mid - 1;\n        }\n        else if (target > arr[mid])\n        {\n            //左闭，mid可以取右边界，这里不用重复比较左边界，所以加一\n            left = mid + 1;\n        }\n        else\n        {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n\n**左闭右开：**\n\n```c#\n/// <summary>\n/// 左闭右开\n/// </summary>\n/// <param name=\"arr\"></param>\n/// <param name=\"target\"></param>\n/// <returns></returns>\npublic int Search2(int[] arr, int target)\n{\n    int mid, left, right;\n    left = 0;\n    right = arr.Length - 1;\n\n    while (left < right)\n    {\n        mid = (left + right) / 2;\n\n        if (target < arr[mid])\n        {\n            //右开，mid不可以取右边界，这里恰好也不用重复比较右边界，所以不变\n            right = mid;\n        }\n        else if (target > arr[mid])\n        {\n            //左闭，mid可以取右边界，这里不用重复比较左边界，所以加一\n            left = mid + 1;\n        }\n        else\n        {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n\n**尝试写的递归（并不符合题目条件，只是想训练一下自己递归的思路）：**\n\n```c#\n/// <summary>\n/// 左闭右闭，尝试写的递归，加上了left和right\n/// </summary>\n/// <param name=\"arr\"></param>\n/// <param name=\"left\"></param>\n/// <param name=\"right\"></param>\n/// <param name=\"target\"></param>\n/// <returns></returns>\npublic int Search3(int[] arr, int left, int right, int target)\n{\n    int mid;\n    mid = (left + right) / 2;\n    if (left>right)\n    {\n        return -1;\n    }\n    else\n    {\n        if (target < arr[mid])\n        {\n            return Search3(arr, left, mid - 1, target);\n        }\n        else if (target > arr[mid])\n        {\n            return Search3(arr, mid + 1, right, target);\n        }\n        else\n        {\n            return mid;\n        }\n    }\n}\n```\n\n# 后记\n\n今天实在是有点忙，还有一题没写，第二天一起补上呜呜呜。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习 二分查找"],"categories":["computerStudy"]},{"title":"行测_判断推理学习(一)：图形推理_位置规律","url":"/2024/04/16/行测-判断推理学习-一-：图形推理-位置规律/","content":"\n识别特征：元素组成相同\n\n# 考点一：平移\n\n方向：直线(上下、左右、斜对角线)、绕圈(顺逆时针)\n\n常见步数：恒定、递增(等差)\n\n# 考点二：旋转、翻转\n\n1.旋转\n方向：顺时针、逆时针\n常见角度45°、90°、180\n\n2.翻转\n左右翻转:竖轴对称\n上下翻转:横轴对称\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["行测 判断推理 图形推理 位置规律"],"categories":["civilStudy"]},{"title":"GAME101_Lecture02学习","url":"/2024/04/16/GAME101-Lecture02学习/","content":"\n# 向量复习\n\n图形学中，未作特殊规定的向量，缺省值（默认值）都是列\n\n![image-20240416184124364](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416184237.png)\n\n- 点积\n- 叉积\n- 正交基与坐标系\n\n\n\n## 点乘\n\n### 点乘基本知识\n\n![image-20240416172958213](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173005.png)\n\n左下角的公式中：点乘可以快速得到两个向量之间的夹角，特别是在两个向量都只是方向的时候。\n\n右下角的公式中：只要我们做一个反余弦，那就可以得到两个向量之间的夹角。 \n\n![image-20240416181413864](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416181414.png)\n\nA表示一个向量（默认列向量），AT是A向量的转置\n\nA的值可以用红色公式表示。\n\n\n\n### 直角坐标系的点积\n\n![image-20240416173414055](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173414.png)\n\n#### 图形学应用\n\n![image-20240416173442667](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173442.png)\n\n- 求两个向量之间的夹角(如光源与表面夹角的余弦)\n- 求一个向量在另一个向量上的投影\n\n\n\n### 投影点积\n\n![image-20240416173507601](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173507.png)\n\n点乘可以把一个向量任意的进行垂直与平行的分解\n\n上图计算向量b向量a的投影时，b的投影向量  = 向量b的长度 · cosθ · 向量a\n\n#### 图形学作用\n\n![image-20240416173534623](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173534.png)\n\n- 测量两个方向的距离\n- 分解向量\n- 确定向前/向后\n\n图形学中，可以计算两个向量或两个方向多么接近。主要通过比较点乘结果，可以判断接近还是远离这两个方向。\n\n![image-20240416173926813](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173926.png)\n\n向量的点乘还可以得到一个前与后的信息。\n\n如图假设向量a给定了某个方向，从a的起点向上为前，向下为后。\n\n向量a与b的点乘会为正数表示其的方向是指向a的前方。向量c反之。\n\n若向量a与某个向量的点乘为0，那么这个向量与向量a垂直。\n\n同理，前面说到点乘可以判断接近还是原理。向量b与向量a越来越远，那么两者的点乘还会越来越等于0（即垂直），随后更远就是与a的方向相反，直到点乘变成-1（此时b与a完全相反）。\n\n\n\n判断两个向量是否接近，其中一个应用——菲涅尔效果（看的角度和面的法线是否重合问题。越重合，说明面是对着相机的。否则面就越侧面（越亮），直到变成负数就是背面了（暗色））\n\n\n\n## 叉乘\n\n### 叉乘基本知识\n\n![image-20240416180608714](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416180608.png)\n\n- 叉积与两个初始向量正交\n- 右手定则确定方向\n- 在构造坐标系中很有用(以后)\n\n右手螺旋定则（有些地方会用左手），可以判断正负（方向）\n\n![image-20240416181639954](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416181640.png)\n\n左侧的公式中，如果在三维坐标系中，x叉乘y是z，那么这个坐标系就是一个右手坐标系。\n\n右侧的公式中，注意向量叉乘自己是0向量。并且叉乘只有反交换律。\n\n![image-20240416182118165](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416182118.png)\n\n在图中下方的公式，是向量可以写成矩阵的形式，然后向量的叉乘可以转换成矩阵乘以向量\n\n### 图形学的应用\n\n![image-20240416182340467](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416182409.png)\n\n- 确定左/右\n- 确定内部/外部\n\n在图形学中，叉乘一是判断左和右，另一个是判断内和外。\n\n![image-20240416182759510](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416182759.png)\n\n在左图中，向量a叉乘向量b、得到z是正的；向量b叉乘向量a、得到的z是负的。这两种都能证明b在a的左侧。\n\n在右图中，ABC的排布是逆时针，AB叉乘AP和BC叉乘AP、AC叉乘AP的z都是向外的（即AP都在所有边的左侧），这能说明P在ABC的中间。\n\nABC的排布变成顺时针也同理。（此处是对三角形做光栅化的基础，可以判断三角形覆盖了那些像素。若值等于0，即该像素刚好在三角形的边上，那么就自己定义）\n\n## 正交基与坐标系\n\n通过这些向量的乘法，就可以定义坐标系。定义坐标系可以把任意一个向量分解到三个轴上（利用点积算投影，然后用投影分解）\n\n![image-20240416190717359](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416190717.png)\n\n如图，假设将uvw设为一个三维坐标系的坐标轴，它们都是单位向量。\n\n假设有一个向量p。我们可以用投影的方式投影到坐标轴上，直接用点乘的结果就可以立刻得到投影的长度。原因解释如下：\n\n- 先假设向量p投影到u轴上，此时计算向量p在向量u上的投影向量。\n- p在向量u上的投影向量  = 向量p的长度 · cosθ · 向量u\n- 向量p点乘向量u=p的长度 × u的长度 × cosθ。\n- 此时u为单位向量，长度为1。\n- 那么，向量p点乘向量u = u的长度 × cosθ，正好就是其投影长度。\n- ![image-20240416200321655](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417184348.png)\n\n# 矩阵复习\n\n![image-20240416190822580](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416190822.png)\n\n- 神奇的2D阵列，在每一个CS课程中萦绕\n- 在图形学中，广泛用于表示变换翻译、旋转、剪切、缩放(下一讲更详细)\n\n## 矩阵乘积知识\n\n![image-20240416191421852](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416191421.png)\n\nm\\*n的矩阵 乘以 n\\*p的矩阵 = m\\*p的矩阵\n\n矩阵乘法运算，黑色框框和蓝色框框分别是两个例子：\n\n- 黑色框框的？，是在结果的第一行第二列，那么就去第一个矩阵中找第一行，第二个矩阵中找第二列，(1\\*6)+(3\\*7) = 27\n- 蓝色框框同理，(5\\*4)+(2\\*3) = 26\n\n![image-20240416192400862](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416192400.png)\n\n矩阵没有任何的交换率。结合律比较有用。\n\n![image-20240416192852730](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416192852.png)\n\n- 将向量视为列矩阵(mx1)\n- 转换点的关键(下一讲)\n- 官方剧透:关于y轴的2D反射\n\n 始终认为，矩阵在左边，向量在右边。 \n\n![image-20240416192945749](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416192945.png)\n\n矩阵的变换（转置）\n\n![image-20240416193013912](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416193014.png)\n\n# 矩阵和向量\n\n![image-20240416193056657](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416193056.png)\n\n向量在矩阵形式上的计算。\n\n# 总结\n\n这节课主要是对线性代数中向量和矩阵的复习，总体来说难度不大。\n\n1.向量主要是其点乘和叉乘的两种乘法。\n\n- 点乘能够用于计算向量之间的投影和向量之间的夹角，能够判断两向量是否相近（菲涅尔效果）\n- 而向量投影主要能测量两个方向的距离、分解向量以及确定向前/向后等，这些特性能够运用到确定直角坐标系上（即确定基坐标，就是确定一个基准的感觉）\n- 叉乘能够用于确定向量之间的位置关系，左右、内外等。\n- 确定内外在后续光栅化用的会很多，而确定左右的方向好像没有提及运用？？后续有涉及到的话在回来补坑。\n\n2.矩阵则是其乘法计算的一些计算方法。\n\n- 计算机的图形信息基本都是用矩阵存储的，信息与信息的计算后续也会涉及。这里闫老师主要是稍微复习了一下。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"GAME101_Lecture01学习","url":"/2024/04/14/GAME101-Lecture01学习/","content":"\n# 系列前言\n\n按照计划，应该是要学习unity shader的技术的。\n\nsiki学院有shader和Shader Graph两方面的学习，其中graphics shader后半部分属于付费课程。秉持着白嫖的心理，想要去研究乐乐老师的《Unity Shader 入门精要》。\n\n乐乐老师的书从评论来说，适合对计算机图形学有一定了解的人。于是根据评论的建议，找到闫老师的GAME101系列课程。\n\n计划在本月（5月前），将系列课程学完，并完成所有的作业。\n\n学习是永无止境的，共勉~\n\n# 笔记\n\n发现的一些好的参考笔记，都放在下面：\n\n[02_Review Of Linear Algebra (yuque.com)](https://www.yuque.com/u21084722/hmh07m/ypaui9)\n\n# 计算机图形学介绍\n\nLecture01主要讲授计算机图形学在生活的运用以及闫老师主要讲授的内容。\n\n这门课程主要分别为光栅化、曲线和曲面、光线追踪和动画/模拟这四个方面的内容。\n\n## 计算机图形学与计算机视觉\n\n可以认为，涉及到一些推测、猜测等方向的，归纳为计算机视觉领域。\n\n以下是老师关于两个领域之间的一个关系图。\n\n![image-20240414212812143](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/14/20240414212812.png)\n\n\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"Shader学习（二）：vs配置","url":"/2024/04/13/Shader学习（二）：vs配置/","content":"\n# Unity中vs的配置\n\n扩展>管理扩展 搜索“Shader”，下载ShaderlabVS插件既可。\n\n注意要将vs关闭再重开。\n\n# 后记\n\n- 后来发现unity这两年已经有了更新的Shader Graph，开始有点纠结是否要继续学习shaderLab还是转战Shader Graph。。。\n- 最后打算还是先学图形学基础，学完对于unity Shader的学习应该会有更多的认识。无论是ShaderLab还是Shader Graph的学习，打算先放一放。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["shader"],"categories":["computerStudy"]},{"title":"Shader学习（一）：基本概念","url":"/2024/04/13/Shader学习（一）：基本概念/","content":"\n# Shader语言\n\n- 计算机的图形渲染，主要由OpenGL或DirectX来完成。\n\n- OpenGl使用的是GLSL sharder语言，DirectX使用的是HLSL sharder语言。\n- 英伟达公司出的CG语言具有跨平台的特性，能够在两个平台上都适用。\n- unity三种Shader语言都可以运行。\n\n# Unity Shader的分类\n\nunity中使用的是ShaderLab编写。ShaderLab是对三种语言进行了重新封装。unity中的Shader分为以下的三类。\n\n## 表面着色器（Surface Shader）\n\n表面着色器是unity对一些Shader进行了封装，比普通的shader书写简单。\n\n可以认为表面着色器是对顶点/片元着色器的封装，实际编译的时候，表面着色器会被转成顶点/片元着色器。\n\n当光源较多时，适合使用表面着色器，unity的表面着色器已经处理了很多的光照细节。\n\n## 顶点/片元着色器（Vertex/Fragment Shader）\n\n基本的着色器。\n\n实现的效果更强大，所有的功能都提供。\n\n## 固定函数着色器（Fixed Function Shader）\n\n在一些旧的设备上特定使用的着色器。目前使用的很少。\n\n\n\n\n\n\n\n\n\n","tags":["shader"],"categories":["computerStudy"]},{"title":"hexo博客搭建","url":"/2024/04/13/hexo博客搭建/","content":"\n# 环境搭建\n\n## 参考文章\n\n搭建环境参考的文章：[【基础篇】hexo博客搭建教程 - huanhao - 博客园 (cnblogs.com)](https://www.cnblogs.com/huanhao/p/hexobase.html)\n\n## 搭建过程中的问题\n\n### cnpm淘宝镜像地址的更换\n\n这是原文中提供的命令和地址：\n\n```\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n在操作过程中，该地址已于2022年6月30日更改：\n\n```\nhttps://registry.npm.taobao.org => https://registry.npmmirror.com\n```\n\n### github配置\n\ngithub为仓库配置ssh时，若本地的ssh文件夹没有config文件，可能会出现配置失败问题。\n\n新建config.txt文件，将下面的命令直接粘贴进去，保存去掉后缀即可\n\n```\nHost github.com\n  Hostname ssh.github.com\n  Port 443\n```\n\n# 图床搭建\n\n环境搭建的大佬也有提及图床的搭建，推荐了Picee。Picee时chrome的插件，电脑主要使用的edge，无意为此专门下载一个chrome，因此在知乎上找到了其他的方法。\n\n## 参考文章\n\n[如何用github搭建图床（亲测有效）_github图床-CSDN博客](https://blog.csdn.net/xdnxl/article/details/129466060)\n\n## 搭建遇到的问题\n\n使用的是picgo。刚开始选择的是最新的beta版本，结果上传不上去。\n\n后来在参考文章里，换成了2.3.1版本。并且根据文章说的，关闭steam++，结果就上传成功了。。。也不知是steam++的问题还是版本的问题。。。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["hexo"],"categories":["computerStudy"]},{"title":"前言","url":"/2024/04/13/前言/","content":"\n第一次按照教程搭建自己的博客，感谢大佬的教程。教程链接：[【基础篇】hexo博客搭建教程 - huanhao - 博客园 (cnblogs.com)](https://www.cnblogs.com/huanhao/p/hexobase.html)\n\n博客用的是hexo搭建的，主题则是github上一位大佬开源的主题：https://github.com/hooozen/hexo-theme-tranquility.git\n\n越学习越发现世界之大，我们只是茫茫人海中小小的一个。大一的时候是在CSDN等上面写的文章，到了大三才想起要自己的博客，也不知会否为时已晚？\n\n但只要想做，什么时候都不算晚吧。\n","tags":["杂项"],"categories":["life"]}]