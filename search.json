[{"title":"GAME101-Lecture03学习","url":"/2024/04/17/GAME101-Lecture03学习/","content":"\n# 变换引入目的\n\n建模、3D转2D（投影）\n\n![image-20240417214811477](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417214818.png)\n\n# 缩放（变换）\n\n![image-20240417233641105](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233641.png)\n\n![image-20240417233647324](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233647.png)\n\n![image-20240417233701179](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233701.png)\n\n# 反射/对称（变换）\n\n![image-20240417233817350](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417233817.png)\n\n# 切变\n\n![image-20240417214916402](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417214916.png)\n\n- 提示:\n- 水平位移在y=0处为0\n- 水平位移在y=1处为a\n- 垂直位移总是0\n\n整体：只是水平方向发生移动，竖直方向没有变化\n\n上面的边：水平方向移动的都是a\n\n中间的位置（y=0.5时）：水平方向移动都是0.5a\n\n总结可以认为，水平位置移动了a*y。x' = x+ay,y'=y，写成矩阵形式就是右下角的样子。\n\n# 旋转（变换）\n\n我们自己规定，任何旋转没有特地说明，都认为是绕着原点(0,0)旋转，旋转方向默认逆时针。\n\n## 旋转矩阵\n\n![image-20240417215439805](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417215439.png)\n\n## 旋转矩阵推导过程\n\n![image-20240417220007752](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417220007.png)\n\n列向量左乘矩阵\n\n- 首先，(x,y)--->(x',y')肯定是x和y分别乘以了某些系数，从而才能达到(x',y')的效果。（前面切变那里的分析过程\n- 按照切变的例子，向量(x',y')可以转化成向量乘矩阵的形式就是闫老师写出的那个ABCD的式子（图中黑色箭头尾端的式子）。此时问题就转化成了解出ABCD的值。\n- 要解矩阵，可以通过到带入特殊值的方式。最上面靠右的图就是闫老师演示的某种特殊情况，(1,0)--->(cosθ,sinθ)，将其带入待解式子即可（图中黑色部分）\n- 要完全解出来四个参数ABCD，找两个特殊解即可。\n\n（弹幕中有补充一般性的问题，闫老师这种解法是可以的）\n\n# 线性变换\n\n![image-20240417221233333](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417221233.png)\n\n如果能把变换写成上图的这种形式（即用矩阵乘以输入的坐标可以得到输出的坐标），这种变换叫做线性变换。\n\n即对于一个变换，用一个矩阵表示。\n\n# 齐次坐标\n\n**引入齐次坐标的主要原因是平移变换比较特殊，简单的表示成前面所需的一个矩阵乘以一个向量的形式，而不是让平移变换成为一个特殊的变换。**\n\n后续的推导起到帮助理解的作用。\n\n## 引入目的\n\n![image-20240417221910780](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417221910.png)\n\n![image-20240417221925820](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417221925.png)\n\n- 平移不能以矩阵形式表示(所以，翻译不是线性变换!)\n- 但我们不希望翻译成为一个特例\n- 是否有一种统一的方式来表示所有的转换?成本是多少\n\n平移的变换主要是加法，看着简单，但是像前面那样，通过矩阵的解法列出的话，会很复杂（如第二幅图）。（弹幕中说，这在线性代数中，叫做非齐次方程）\n\n并且，由于平移的变换中，矩阵乘法后面还要做一个加法，因此平移变换不是线性变换\n\n## 齐次坐标的解决方案\n\n用齐次坐标，通过增加一个数（一个维度）让平移变换写成矩阵乘以向量的形式（其他的线性变换也可以这么写），如下图(x',y',w')的变换：\n\n![image-20240417223038073](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417223038.png)\n\n## 齐次的“保护性”\n\n向量表示的是方向性，向量平移表示的任是同一个向量，这说明向量具有平移不变性。\n\n那么如果有一个向量(x,y,0)，经过矩阵的变换，若想让他不变（依旧是(x+t,y+t,0)）。可以增加一个0（一个维度）保护他。\n\n![image-20240417223410477](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417223410.png)\n\n- 齐次坐标\n- 如果结果的w坐标为1或0，则有效操作\n\n在空间中（二维或三维），向量加上向量（三角形法则）得到一个新的向量。\n\n点减去点，得到新的向量。\n\n点加上向量，点沿着一条线移动，移动到一个新的点上。\n\n点加点的扩充定义：在二维中，当w不等于0，可以让其转成（x/w,y/w,1)，w=1就可以表示成一个二维的点(x/w,y/w)。\n\n因此点加点得到的是这两个点的中点\n\n上述阐述了，最后一位是0，不仅保证了其平移不变性，还能保证在操作下是对的。\n\n\n\n# 仿射变换\n\n![image-20240417224820539](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417224820.png)\n\n图中上方的式子，我们称为仿射变换。\n\n在图中下方的式子中，我们用一个式子（齐次坐标）表示了所有的变换\n\n用齐次坐标去**表示二维的仿射变化**时，可以发现：\n\n- 矩阵的最后一行永远是001\n- 平移永远是写在最后一列的头两个数上\n- 前两列的前两个元素是原来线性变换的部分\n\n# 2D（二维）变换\n\n![image-20240417225121008](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225121.png)\n\n缩放变换中，没有平移，因此最后一列头两个数是00。\n\n旋转变换中，平移和缩放同理。\n\n平移变换中，没有经过线性变换，左上角是单位矩阵1001，有平移因此最后一列头两个数是tx ty。\n\n# 逆变换\n\n![image-20240417225508580](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225508.png)\n\n逆变换在矩阵中，就是乘以逆矩阵。\n\n# 组合变换\n\n![image-20240417225649265](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225649.png)\n\n- 如何才能从左边变换成右边？\n\n![image-20240417225656282](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225656.png)\n\n- 先平移再旋转，发现不可行\n\n![image-20240417225705466](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225705.png)\n\n- 先旋转在平移，发现可行\n\n通过上面的例子，可以知道\n\n- 复杂的变换可以通过简单的变化得到\n- 变换的顺序很重要\n- 这和矩阵的乘法一致，矩阵没有交换律\n\n![image-20240417225940346](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417225940.png)\n\n向量默认时一个列矩阵，因此做变换的时候需要从左往右乘。（如图，列矩阵xy1先做旋转再做平移，因此先左乘一个R再左乘一个T）\n\n## 推广\n\n![image-20240417230313249](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417230313.png)\n\n- 仿射变换序列A1、A2、A3,…由矩阵乘法构成\n- 对性能非常重要！\n- 对n个矩阵进行预相乘以获得表示组合变换的单个矩阵\n\n先将前面的矩阵全部乘完，乘完还是一个3\\*3的矩阵。这说明一个3\\*3的矩阵可以表示很复杂的变换。\n\n# 分解变换\n\n![image-20240417230947003](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417230947.png)\n\n- 如何围绕一个给定的点c旋转?\n- 将中心转换为原点\n- 旋转\n- 移动回来\n\n相当于在二维中，图形绕着任意一个点旋转，都可以转换成：先把图形平移使得旋转点与原点重合，再绕原点旋转，然后再把旋转后的图形移回相同的参数\n\n# 3D变换\n\n三维空间的变换，可以类比二维的。\n\n注意区别，三维的点和向量增加一个数（升维）后，并不是四元数，四元数是专门用来表示旋转的。\n\n![image-20240417231500879](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417231500.png)\n\n- 再次使用齐次坐标\n\n![image-20240417231558326](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417231558.png)\n\n最后一行还是0001\n\n平移：依旧是在最后一列\n\n线性变换：左上角的3\\*3矩阵\n\n# 课堂启发\n\n可以把仿射变换写成一个简单的矩阵形式，矩阵表示线性操作和平移操作。\n\n# 课堂问题\n\n闫老师留下来的问题：在三维的变换中，矩阵应用在xyz这个三维点上，是先平移还是先线性变换呢？\n\n解答：可以看前面，2D下仿射变换的式子，是线性变换（矩阵乘以向量）加上平移变换。因此是先线性变换再平移变换。\n\n# 总结\n\n今天讲的是各种变换，前面所有的变换都是以2D为例的，3D其实也是同理。\n\n缩放、对称、旋转等这些变换，能够直接用矩阵乘以向量的形式表示，称为线性变换。\n\n平移不能以矩阵乘以向量表示，并不是平移变换。其形式是矩阵乘以向量加上一个矩阵，可以称之为仿射变换。\n\n如果将平移看作特殊的变化，那又太过麻烦。为了让所有的变换具有统一性，引入了齐次坐标的知识。\n\n齐次坐标能够通过加一个数（升维）的方式，通过齐次坐标来表示仿射变换。其次坐标也可以表示线性变换。\n\n因此，能够用齐次坐标的方式，将所有的变换转变成矩阵与向量的形式。\n\n将单一的变换累加，就是组合变换。组合变换中，变换的顺序很重要。\n\n在组合变换中发现，先将所有的变换矩阵相乘，还是能得到一个矩阵，这说明任何复杂的变换都能用一个矩阵来表示。\n\n\n\n\n\n","categories":["computerStudy"]},{"title":"算法练习day1","url":"/2024/04/17/算法练习day1/","content":"\n# 前言\n\n大二开始定下实践项目的主方向后，对于数据结构、算法这一块基本就是停滞状态了。\n\n选择游戏方向后，unity和C#的实际项目对于算法方面的要求并不多。实习需要去大厂，并且为了进一步提高自己的能力，决定接下来的日子里苦练算法。\n\n以前练习算法这方面，用的都是C、Java这类。用C#写还是头一次，在练习算法的同时，增进自己对C#的使用熟练度，也是一举两得。\n\n接下来的日子，打算跟着卡哥的《算法随想录》刷题。根据http://t.csdnimg.cn/l8b7i，这篇大哥的博客，每天进行练习。自己练习确实得要很大的毅力和决心，希望自己能够坚持下来，共勉~\n\n# 二分查找\n\n[代码随想录 二分查找](https://www.programmercarl.com/0704.二分查找.html)\n\n[力扣 704.二分查找](https://leetcode.cn/problems/binary-search/)\n\n（用时：1.5小时）\n\n写的过程中出现了错误，思考了10分钟无法解决后，找了参考代码进行了纠错。错误如下：\n\n- 错误一：target < arr[mid]写成了target < mid\n- 错误二：写成了递归（也不算是错误，递归也能实现二分查找。但写的混合了递归和非递归，导致写的非常混乱！这也是对递归没有很好的理解。后来理清非递归后，重新写了下递归，一起放在后面了）\n- 错误三：左闭右开时，right = mid写成了right = mid-1\n\n## 错误复盘\n\n**错误一分析：**mid是一个下标，在target是一个值，比较的时候应是拿值比较。这里是对mid和target的关系没有更加深刻的理解，当查找到时，两者关系：target=arr[mid]\n\n**错误二分析：**写成了递归这个错误就emmmm，其实是可以写成递归的。递归之前也一直是迈不过去的坎，导致这里先入为主了。递归是写出来了，但并不是题目格式的要求。。每天的时间有限，第一遍刷更侧重于复习回顾理解，第二遍再拓展深究。\n\n**错误三分析：**\n\n- 卡哥视频二分查找有两个重点，一是while的判断条件，二是if里的判断条件。\n\n- while的判断条件看开闭区间，看left=right是否能取即可。\n\n- if判断条件也是看开闭区间，这里是看left是否能等于区间左侧、right是否能等于区间右侧\n\n  例如，假设  区间为[i,j)   mid=(i+j)/2，left=mid、左闭是可取的，right=mid、右开不可取\n\n  ![image-20240417185239607](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417185239.png)\n\n## 正解\n\n**左闭右闭：**\n\n```c#\n/// <summary>\n/// 左闭右闭\n/// </summary>\n/// <param name=\"arr\"></param>\n/// <param name=\"target\"></param>\npublic int Search1(int[] arr, int target)\n{\n    int mid, left, right;\n    left = 0;\n    right = arr.Length - 1;\n    //左闭右闭，left可以等于right\n    while (left <= right)\n    {\n        mid = (left + right) / 2;\n        if (target < arr[mid])\n        {\n            //右闭，mid可以取右边界，这里不用重复比较右边界，所以减一\n            right = mid - 1;\n        }\n        else if (target > arr[mid])\n        {\n            //左闭，mid可以取右边界，这里不用重复比较左边界，所以加一\n            left = mid + 1;\n        }\n        else\n        {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n\n**左闭右开：**\n\n```c#\n/// <summary>\n/// 左闭右开\n/// </summary>\n/// <param name=\"arr\"></param>\n/// <param name=\"target\"></param>\n/// <returns></returns>\npublic int Search2(int[] arr, int target)\n{\n    int mid, left, right;\n    left = 0;\n    right = arr.Length - 1;\n\n    while (left < right)\n    {\n        mid = (left + right) / 2;\n\n        if (target < arr[mid])\n        {\n            //右开，mid不可以取右边界，这里恰好也不用重复比较右边界，所以不变\n            right = mid;\n        }\n        else if (target > arr[mid])\n        {\n            //左闭，mid可以取右边界，这里不用重复比较左边界，所以加一\n            left = mid + 1;\n        }\n        else\n        {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n\n**尝试写的递归（并不符合题目条件，只是想训练一下自己递归的思路）：**\n\n```c#\n/// <summary>\n/// 左闭右闭，尝试写的递归，加上了left和right\n/// </summary>\n/// <param name=\"arr\"></param>\n/// <param name=\"left\"></param>\n/// <param name=\"right\"></param>\n/// <param name=\"target\"></param>\n/// <returns></returns>\npublic int Search3(int[] arr, int left, int right, int target)\n{\n    int mid;\n    mid = (left + right) / 2;\n    if (left>right)\n    {\n        return -1;\n    }\n    else\n    {\n        if (target < arr[mid])\n        {\n            return Search3(arr, left, mid - 1, target);\n        }\n        else if (target > arr[mid])\n        {\n            return Search3(arr, mid + 1, right, target);\n        }\n        else\n        {\n            return mid;\n        }\n    }\n}\n```\n\n# 后记\n\n今天实在是有点忙，还有一题没写，第二天一起补上呜呜呜。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["数据结构 算法练习 二分查找"],"categories":["computerStudy"]},{"title":"行测_判断推理学习(一)：图形推理_位置规律","url":"/2024/04/16/行测-判断推理学习-一-：图形推理-位置规律/","content":"\n识别特征：元素组成相同\n\n# 考点一：平移\n\n方向：直线(上下、左右、斜对角线)、绕圈(顺逆时针)\n\n常见步数：恒定、递增(等差)\n\n# 考点二：旋转、翻转\n\n1.旋转\n方向：顺时针、逆时针\n常见角度45°、90°、180\n\n2.翻转\n左右翻转:竖轴对称\n上下翻转:横轴对称\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["行测 判断推理 图形推理 位置规律"],"categories":["civilStudy"]},{"title":"GAME101_Lecture02学习","url":"/2024/04/16/GAME101-Lecture02学习/","content":"\n# 向量复习\n\n图形学中，未作特殊规定的向量，缺省值（默认值）都是列\n\n![image-20240416184124364](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416184237.png)\n\n- 点积\n- 叉积\n- 正交基与坐标系\n\n\n\n## 点乘\n\n### 点乘基本知识\n\n![image-20240416172958213](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173005.png)\n\n左下角的公式中：点乘可以快速得到两个向量之间的夹角，特别是在两个向量都只是方向的时候。\n\n右下角的公式中：只要我们做一个反余弦，那就可以得到两个向量之间的夹角。 \n\n![image-20240416181413864](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416181414.png)\n\nA表示一个向量（默认列向量），AT是A向量的转置\n\nA的值可以用红色公式表示。\n\n\n\n### 直角坐标系的点积\n\n![image-20240416173414055](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173414.png)\n\n#### 图形学应用\n\n![image-20240416173442667](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173442.png)\n\n- 求两个向量之间的夹角(如光源与表面夹角的余弦)\n- 求一个向量在另一个向量上的投影\n\n\n\n### 投影点积\n\n![image-20240416173507601](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173507.png)\n\n点乘可以把一个向量任意的进行垂直与平行的分解\n\n上图计算向量b向量a的投影时，b的投影向量  = 向量b的长度 · cosθ · 向量a\n\n#### 图形学作用\n\n![image-20240416173534623](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173534.png)\n\n- 测量两个方向的距离\n- 分解向量\n- 确定向前/向后\n\n图形学中，可以计算两个向量或两个方向多么接近。主要通过比较点乘结果，可以判断接近还是远离这两个方向。\n\n![image-20240416173926813](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416173926.png)\n\n向量的点乘还可以得到一个前与后的信息。\n\n如图假设向量a给定了某个方向，从a的起点向上为前，向下为后。\n\n向量a与b的点乘会为正数表示其的方向是指向a的前方。向量c反之。\n\n若向量a与某个向量的点乘为0，那么这个向量与向量a垂直。\n\n同理，前面说到点乘可以判断接近还是原理。向量b与向量a越来越远，那么两者的点乘还会越来越等于0（即垂直），随后更远就是与a的方向相反，直到点乘变成-1（此时b与a完全相反）。\n\n\n\n判断两个向量是否接近，其中一个应用——菲涅尔效果（看的角度和面的法线是否重合问题。越重合，说明面是对着相机的。否则面就越侧面（越亮），直到变成负数就是背面了（暗色））\n\n\n\n## 叉乘\n\n### 叉乘基本知识\n\n![image-20240416180608714](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416180608.png)\n\n- 叉积与两个初始向量正交\n- 右手定则确定方向\n- 在构造坐标系中很有用(以后)\n\n右手螺旋定则（有些地方会用左手），可以判断\n\n![image-20240416181639954](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416181640.png)\n\n左侧的公式中，如果在三维坐标系中，x叉乘y是z，那么这个坐标系就是一个右手坐标系。\n\n右侧的公式中，注意向量叉乘自己是0向量。并且叉乘只有反交换律。\n\n![image-20240416182118165](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416182118.png)\n\n在下方的公式，是向量可以写成矩阵的形式，然后向量的叉乘可以转换成矩阵乘以向量\n\n### 图形学的应用\n\n![image-20240416182340467](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416182409.png)\n\n- 确定左/右\n- 确定内部/外部\n\n在图形学中，叉乘一是判断左和右，另一个是判断内和外。\n\n![image-20240416182759510](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416182759.png)\n\n在左图中，向量a叉乘向量b、得到z是正的；向量b叉乘向量a、得到的z是负的。这两种都能证明b在a的左侧。\n\n在右图中，ABC的排布是逆时针，AB叉乘AP和BC叉乘AP、AC叉乘AP的z都是向外的（即AP都在所有边的左侧），这能说明P在ABC的中间。\n\nABC的排布变成顺时针也同理。（此处是对三角形做光栅化的基础，可以判断三角形覆盖了那些像素。若值等于0，即该像素刚好在三角形的边上，那么就自己定义）\n\n## 正交基与坐标系\n\n通过这些向量的乘法，就可以定义坐标系。定义坐标系可以把任意一个向量分解到三个轴上（利用点积算投影，然后用投影分解）\n\n![image-20240416190717359](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416190717.png)\n\n如图，假设将uvw设为一个三维坐标系的坐标轴，它们都是单位向量。\n\n假设有一个向量p。我们可以用投影的方式投影到坐标轴上，直接用点乘的结果就可以立刻得到投影的长度。原因解释如下：\n\n- 先假设向量p投影到u轴上，此时计算向量p在向量u上的投影向量。\n- p在向量u上的投影向量  = 向量p的长度 · cosθ · 向量u\n- 向量p点乘向量u=p的长度 × u的长度 × cosθ。\n- 此时u为单位向量，长度为1。\n- 那么，向量p点乘向量u = u的长度 × cosθ，正好就是其投影长度。\n- （picgo上传出了问题，后面再补坑吧呜呜呜）![image-20240416200321655](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/17/20240417184348.png)\n\n# 矩阵复习\n\n![image-20240416190822580](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416190822.png)\n\n- 神奇的2D阵列，在每一个CS课程中萦绕\n- 在图形学中，广泛用于表示变换翻译、旋转、剪切、缩放(下一讲更详细)\n\n## 矩阵乘积知识\n\n![image-20240416191421852](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416191421.png)\n\nm\\*n的矩阵 乘以 n\\*p的矩阵 = m\\*p的矩阵\n\n矩阵乘法运算，黑色框框和蓝色框框分别是两个例子：\n\n- 黑色框框的？，是在结果的第一行第二列，那么就去第一个矩阵中找第一行，第二个矩阵中找第二列，(1\\*6)+(3\\*7) = 27\n- 蓝色框框同理，(5\\*4)+(2\\*3) = 26\n\n![image-20240416192400862](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416192400.png)\n\n矩阵没有任何的交换率。结合律比较有用。\n\n![image-20240416192852730](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416192852.png)\n\n- 将向量视为列矩阵(mx1)\n- 转换点的关键(下一讲)\n- 官方剧透:关于y轴的2D反射\n\n 始终认为，矩阵在左边，向量在右边。 \n\n![image-20240416192945749](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416192945.png)\n\n矩阵的变换（转置）\n\n![image-20240416193013912](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416193014.png)\n\n# 矩阵和向量\n\n![image-20240416193056657](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/16/20240416193056.png)\n\n向量在矩阵形式上的计算。\n\n# 总结\n\n这节课主要是对线性代数中向量和矩阵的复习，总体来说难度不大。\n\n1.向量主要是其点乘和叉乘的两种乘法。\n\n- 点乘能够用于计算向量之间的投影和向量之间的夹角，能够判断两向量是否相近（菲涅尔效果）\n- 而向量投影主要能测量两个方向的距离、分解向量以及确定向前/向后等，这些特性能够运用到确定直角坐标系上（即确定基坐标，就是确定一个基准的感觉）\n- 叉乘能够用于确定向量之间的位置关系，左右、内外等。\n- 确定内外在后续光栅化用的会很多，而确定左右的方向好像没有提及运用？？后续有涉及到的话在回来补坑。\n\n2.矩阵则是其乘法计算的一些计算方法。\n\n- 计算机的图形信息基本都是用矩阵存储的，信息与信息的计算后续也会涉及。这里闫老师主要是稍微复习了一下。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"GAME101_Lecture01学习","url":"/2024/04/14/GAME101-Lecture01学习/","content":"\n# 系列前言\n\n按照计划，应该是要学习unity shader的技术的。\n\nsiki学院有shader和Shader Graph两方面的学习，其中graphics shader后半部分属于付费课程。秉持着白嫖的心理，想要去研究乐乐老师的《Unity Shader 入门精要》。\n\n乐乐老师的书从评论来说，适合对计算机图形学有一定了解的人。于是根据评论的建议，找到闫老师的GAME101系列课程。\n\n计划在本月（5月前），将系列课程学完，并完成所有的作业。\n\n学习是永无止境的，共勉~\n\n# 笔记\n\n发现的一些好的参考笔记，都放在下面：\n\n[02_Review Of Linear Algebra (yuque.com)](https://www.yuque.com/u21084722/hmh07m/ypaui9)\n\n# 计算机图形学介绍\n\nLecture01主要讲授计算机图形学在生活的运用以及闫老师主要讲授的内容。\n\n这门课程主要分别为光栅化、曲线和曲面、光线追踪和动画/模拟这四个方面的内容。\n\n## 计算机图形学与计算机视觉\n\n可以认为，涉及到一些推测、猜测等方向的，归纳为计算机视觉领域。\n\n以下是老师关于两个领域之间的一个关系图。\n\n![image-20240414212812143](https://cdn.jsdelivr.net/gh/Disjoint3/ImgHost@main/Img/2024/04/14/20240414212812.png)\n\n\n\n\n\n\n\n","tags":["计算机图形学 GAME101"],"categories":["computerStudy"]},{"title":"Shader学习（二）：vs配置","url":"/2024/04/13/Shader学习（二）：vs配置/","content":"\n# Unity中vs的配置\n\n扩展>管理扩展 搜索“Shader”，下载ShaderlabVS插件既可。\n\n注意要将vs关闭再重开。\n\n# 后记\n\n- 后来发现unity这两年已经有了更新的Shader Graph，开始有点纠结是否要继续学习shaderLab还是转战Shader Graph。。。\n- 最后打算还是先学图形学基础，学完对于unity Shader的学习应该会有更多的认识。无论是ShaderLab还是Shader Graph的学习，打算先放一放。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["shader"],"categories":["computerStudy"]},{"title":"Shader学习（一）：基本概念","url":"/2024/04/13/Shader学习（一）：基本概念/","content":"\n# Shader语言\n\n- 计算机的图形渲染，主要由OpenGL或DirectX来完成。\n\n- OpenGl使用的是GLSL sharder语言，DirectX使用的是HLSL sharder语言。\n- 英伟达公司出的CG语言具有跨平台的特性，能够在两个平台上都适用。\n- unity三种Shader语言都可以运行。\n\n# Unity Shader的分类\n\nunity中使用的是ShaderLab编写。ShaderLab是对三种语言进行了重新封装。unity中的Shader分为以下的三类。\n\n## 表面着色器（Surface Shader）\n\n表面着色器是unity对一些Shader进行了封装，比普通的shader书写简单。\n\n可以认为表面着色器是对顶点/片元着色器的封装，实际编译的时候，表面着色器会被转成顶点/片元着色器。\n\n当光源较多时，适合使用表面着色器，unity的表面着色器已经处理了很多的光照细节。\n\n## 顶点/片元着色器（Vertex/Fragment Shader）\n\n基本的着色器。\n\n实现的效果更强大，所有的功能都提供。\n\n## 固定函数着色器（Fixed Function Shader）\n\n在一些旧的设备上特定使用的着色器。目前使用的很少。\n\n\n\n\n\n\n\n\n\n","tags":["shader"],"categories":["computerStudy"]},{"title":"hexo博客搭建","url":"/2024/04/13/hexo博客搭建/","content":"\n# 环境搭建\n\n## 参考文章\n\n搭建环境参考的文章：[【基础篇】hexo博客搭建教程 - huanhao - 博客园 (cnblogs.com)](https://www.cnblogs.com/huanhao/p/hexobase.html)\n\n## 搭建过程中的问题\n\n### cnpm淘宝镜像地址的更换\n\n这是原文中提供的命令和地址：\n\n```\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n在操作过程中，该地址已于2022年6月30日更改：\n\n```\nhttps://registry.npm.taobao.org => https://registry.npmmirror.com\n```\n\n### github配置\n\ngithub为仓库配置ssh时，若本地的ssh文件夹没有config文件，可能会出现配置失败问题。\n\n新建config.txt文件，将下面的命令直接粘贴进去，保存去掉后缀即可\n\n```\nHost github.com\n  Hostname ssh.github.com\n  Port 443\n```\n\n# 图床搭建\n\n环境搭建的大佬也有提及图床的搭建，推荐了Picee。Picee时chrome的插件，电脑主要使用的edge，无意为此专门下载一个chrome，因此在知乎上找到了其他的方法。\n\n## 参考文章\n\n[如何用github搭建图床（亲测有效）_github图床-CSDN博客](https://blog.csdn.net/xdnxl/article/details/129466060)\n\n## 搭建遇到的问题\n\n使用的是picgo。刚开始选择的是最新的beta版本，结果上传不上去。\n\n后来在参考文章里，换成了2.3.1版本。并且根据文章说的，关闭steam++，结果就上传成功了。。。也不知是steam++的问题还是版本的问题。。。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["hexo"],"categories":["computerStudy"]},{"title":"前言","url":"/2024/04/13/前言/","content":"\n第一次按照教程搭建自己的博客，感谢大佬的教程。教程链接：[【基础篇】hexo博客搭建教程 - huanhao - 博客园 (cnblogs.com)](https://www.cnblogs.com/huanhao/p/hexobase.html)\n\n博客用的是hexo搭建的，主题则是github上一位大佬开源的主题：https://github.com/hooozen/hexo-theme-tranquility.git\n\n越学习越发现世界之大，我们只是茫茫人海中小小的一个。大一的时候是在CSDN等上面写的文章，到了大三才想起要自己的博客，也不知会否为时已晚？\n\n但只要想做，什么时候都不算晚吧。\n","tags":["杂项"],"categories":["life"]}]